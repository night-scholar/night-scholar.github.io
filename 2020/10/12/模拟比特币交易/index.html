<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Night Scholar">





<title>Go语言模拟比特币交易 | Night-Scholar’s Blog</title>



    <link rel="icon" href="/avatar.jpeg">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">夜行书生&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" target="_blank" rel="noopener" href="https://bafybeibjnkt6a5g5mccqyqjb2zdiveizwaueyt522dl2ctgfz642hztx34.ipfs.infura-ipfs.io/">IPFS</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">夜行书生&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" target="_blank" rel="noopener" href="https://bafybeibjnkt6a5g5mccqyqjb2zdiveizwaueyt522dl2ctgfz642hztx34.ipfs.infura-ipfs.io/">IPFS</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
        
            <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到首部</a>
        <a onclick="go_bottom()">直达底部</a>
    </div>
</div>

<script>
    document.ready(
        function() {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "全部折叠"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "全部展开"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }
</script>
                

                    
                        <article class="post-wrap">
                            <header class="post-header">
                                <h1 class="post-title">
                                    Go语言模拟比特币交易
                                </h1>
                                
                                    <div class="post-meta">
                                        
                                            Author:
                                            <a itemprop="author" rel="author" href="/">
                                                Night Scholar
                                            </a>
                                            

                                                
                                                    <span class="post-time">
                        Date: <a href="#">October 12, 2020&nbsp;&nbsp;23:03:02</a>
                        </span>
                                                    
                                                        
                                                            <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a>
                            
                        </span>
                                                            
                                    </div>
                                    
                            </header>

                            <div class="post-content">
                                <h2 id="git代码管理"><a href="#git代码管理" class="headerlink" title="git代码管理"></a>git代码管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://gitee.com/用户个性地址/HelloGitee.git #将远程仓库克隆到本地</span><br><span class="line">$ git config --global user.name &quot;你的名字或昵称&quot;</span><br><span class="line">$ git config --global user.email &quot;你的邮箱&quot;</span><br><span class="line">$ git add . #将当前目录所有文件添加到git暂存区</span><br><span class="line">$ git commit -m &quot;my first commit&quot; #提交并备注提交信息</span><br><span class="line">$ git push origin master #将本地提交推送到远程仓库</span><br></pre></td></tr></table></figure>

<h2 id="一个简单的区块链"><a href="#一个简单的区块链" class="headerlink" title="一个简单的区块链"></a>一个简单的区块链</h2><h3 id="block-go"><a href="#block-go" class="headerlink" title="block.go"></a>block.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> genesisInfo = <span class="string">&quot;第一个区块&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">	PrevBlockHash []<span class="keyword">byte</span> <span class="comment">//前区块哈希</span></span><br><span class="line">	Hash          []<span class="keyword">byte</span> <span class="comment">//当前区块哈希</span></span><br><span class="line">	Data          []<span class="keyword">byte</span> <span class="comment">//数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建区块 对Block的每一个字段填充数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(data <span class="keyword">string</span>, prevBlockHash []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line">	block := Block&#123;</span><br><span class="line">		PrevBlockHash: prevBlockHash,</span><br><span class="line">		Hash:          []<span class="keyword">byte</span>&#123;&#125;,     <span class="comment">//先填充为空</span></span><br><span class="line">		Data:          []<span class="keyword">byte</span>(data), <span class="comment">//类型转换</span></span><br><span class="line">	&#125;</span><br><span class="line">	block.SetHash()</span><br><span class="line">	<span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了生成区块哈希，我们生成一个简单的函数来计算哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(block *Block)</span> <span class="title">SetHash</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data []<span class="keyword">byte</span></span><br><span class="line">	data = <span class="built_in">append</span>(data, block.PrevBlockHash...)</span><br><span class="line">	data = <span class="built_in">append</span>(data, block.Data...)</span><br><span class="line">	hash := sha256.Sum256(data) <span class="comment">//hash是一个32位的数组</span></span><br><span class="line">	block.Hash = hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="blockchain-go"><a href="#blockchain-go" class="headerlink" title="blockchain.go"></a>blockchain.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建区块链 使用Block数组模拟</span></span><br><span class="line"><span class="keyword">type</span> BlockChain <span class="keyword">struct</span> &#123;</span><br><span class="line">	Blocks []*Block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现创建区块链的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockChain</span><span class="params">()</span> *<span class="title">BlockChain</span></span> &#123;</span><br><span class="line">	<span class="comment">//在创建的时候添加一个区块：创世块</span></span><br><span class="line">	genesisBlock := NewBlock(genesisInfo, []<span class="keyword">byte</span>&#123;<span class="number">0x000000000000000</span>&#125;)</span><br><span class="line"></span><br><span class="line">	bc := BlockChain&#123;Blocks: []*Block&#123;genesisBlock&#125;&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;bc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">AddBlock</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//bc.Blocks的最后一个区块的Hash值就是当前新区块的前哈希</span></span><br><span class="line">	lastBlock := bc.Blocks[<span class="built_in">len</span>(bc.Blocks)<span class="number">-1</span>]</span><br><span class="line">	prevHash := lastBlock.Hash</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.创建一个区块</span></span><br><span class="line">	block := NewBlock(data, prevHash)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.添加倒bc.Blocks数组中</span></span><br><span class="line">	bc.Blocks = <span class="built_in">append</span>(bc.Blocks, block)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//区块实例化</span></span><br><span class="line">	<span class="comment">//block := NewBlock(genesisInfo, []byte&#123;0x000000000000000&#125;)</span></span><br><span class="line">	bc := NewBlockChain()</span><br><span class="line">	bc.AddBlock(<span class="string">&quot;第二个区块&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> index, block := <span class="keyword">range</span> bc.Blocks &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;第%d个区块:\n&quot;</span>, index+<span class="number">1</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;PrevBlockHash : %x\n&quot;</span>, block.PrevBlockHash)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Hash : %x\n&quot;</span>, block.Hash)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Data : %s\n&quot;</span>, block.Data)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="升级版区块链"><a href="#升级版区块链" class="headerlink" title="升级版区块链"></a>升级版区块链</h2><h3 id="1-更新补充区块字段"><a href="#1-更新补充区块字段" class="headerlink" title="1. 更新补充区块字段"></a>1. 更新补充区块字段</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">	Version       <span class="keyword">uint64</span> <span class="comment">//区块版本号</span></span><br><span class="line">	PrevBlockHash []<span class="keyword">byte</span> <span class="comment">//前区块哈希</span></span><br><span class="line">	MerkleRoot    []<span class="keyword">byte</span> <span class="comment">//Merkle根</span></span><br><span class="line">	TimeStamp     <span class="keyword">uint64</span> <span class="comment">//从1970年1月1日至今的秒数</span></span><br><span class="line">	Difficulity   <span class="keyword">uint64</span> <span class="comment">//挖矿的难度值</span></span><br><span class="line">	Nonce         <span class="keyword">uint64</span> <span class="comment">//随机数</span></span><br><span class="line">	Hash          []<span class="keyword">byte</span> <span class="comment">//当前区块哈希</span></span><br><span class="line">	Data          []<span class="keyword">byte</span> <span class="comment">//数据，目前为字节流 后续使用交易代替</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-更新NewBlock函数"><a href="#2-更新NewBlock函数" class="headerlink" title="2.更新NewBlock函数"></a>2.更新NewBlock函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建区块 对Block的每一个字段填充数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(data <span class="keyword">string</span>, prevBlockHash []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line">	block := Block&#123;</span><br><span class="line">		Version:       <span class="number">00</span>,</span><br><span class="line">		PrevBlockHash: prevBlockHash,</span><br><span class="line">		MerkleRoot:    []<span class="keyword">byte</span>&#123;&#125;, <span class="comment">//先填充为空</span></span><br><span class="line">		TimeStamp:     <span class="keyword">uint64</span>(time.Now().Unix()),</span><br><span class="line">		Difficulity:   <span class="number">10</span>,           <span class="comment">//随便写的</span></span><br><span class="line">		Nonce:         <span class="number">10</span>,           <span class="comment">//随便写的</span></span><br><span class="line">		Hash:          []<span class="keyword">byte</span>&#123;&#125;,     <span class="comment">//先填充为空</span></span><br><span class="line">		Data:          []<span class="keyword">byte</span>(data), <span class="comment">//类型转换</span></span><br><span class="line">	&#125;</span><br><span class="line">	block.SetHash()</span><br><span class="line">	<span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-更新SetHash函数"><a href="#3-更新SetHash函数" class="headerlink" title="3.更新SetHash函数"></a>3.更新SetHash函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了生成区块哈希，我们生成一个简单的函数来计算哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(block *Block)</span> <span class="title">SetHash</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data []<span class="keyword">byte</span></span><br><span class="line">	<span class="comment">//uintToByte将数字转成byte</span></span><br><span class="line">	data = <span class="built_in">append</span>(data, uintToByte(block.Version)...)</span><br><span class="line">	data = <span class="built_in">append</span>(data, block.PrevBlockHash...)</span><br><span class="line">	data = <span class="built_in">append</span>(data, block.MerkleRoot...)</span><br><span class="line">	data = <span class="built_in">append</span>(data, uintToByte(block.TimeStamp)...)</span><br><span class="line">	data = <span class="built_in">append</span>(data, uintToByte(block.Difficulity)...)</span><br><span class="line">	data = <span class="built_in">append</span>(data, uintToByte(block.Nonce)...)</span><br><span class="line">	data = <span class="built_in">append</span>(data, block.Data...)</span><br><span class="line">	<span class="comment">//data = append(data, block.Hash...)</span></span><br><span class="line"></span><br><span class="line">	hash := sha256.Sum256(data) <span class="comment">//hash是一个32位的数组</span></span><br><span class="line">	block.Hash = hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-创建utils-go文件，添加函数uintToByte，将uint64类型转换为byte类型"><a href="#4-创建utils-go文件，添加函数uintToByte，将uint64类型转换为byte类型" class="headerlink" title="4.创建utils.go文件，添加函数uintToByte，将uint64类型转换为byte类型"></a>4.创建utils.go文件，添加函数uintToByte，将uint64类型转换为byte类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个工具函数文件</span></span><br><span class="line"><span class="comment">//将数字转成byte类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uintToByte</span><span class="params">(num <span class="keyword">uint64</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">	<span class="comment">//使用binary.Write来进行编码</span></span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">	<span class="comment">//编码要进行校验</span></span><br><span class="line">	err := binary.Write(&amp;buffer, binary.BigEndian, num)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buffer.Bytes()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可使用binary.Read()进行解码</span></span><br></pre></td></tr></table></figure>

<h3 id="5-将SetHash函数中的append函数修改为bytes-Jion函数，优化代码"><a href="#5-将SetHash函数中的append函数修改为bytes-Jion函数，优化代码" class="headerlink" title="5.将SetHash函数中的append函数修改为bytes.Jion函数，优化代码"></a>5.将SetHash函数中的append函数修改为bytes.Jion函数，优化代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了生成区块哈希，我们生成一个简单的函数来计算哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(block *Block)</span> <span class="title">SetHash</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data []<span class="keyword">byte</span></span><br><span class="line">	<span class="comment">//uintToByte将数字转成byte</span></span><br><span class="line">	<span class="comment">//data = append(data, uintToByte(block.Version)...)</span></span><br><span class="line">	<span class="comment">//data = append(data, block.PrevBlockHash...)</span></span><br><span class="line">	<span class="comment">//data = append(data, block.MerkleRoot...)</span></span><br><span class="line">	<span class="comment">//data = append(data, uintToByte(block.TimeStamp)...)</span></span><br><span class="line">	<span class="comment">//data = append(data, uintToByte(block.Difficulity)...)</span></span><br><span class="line">	<span class="comment">//data = append(data, uintToByte(block.Nonce)...)</span></span><br><span class="line">	<span class="comment">//data = append(data, block.Data...)</span></span><br><span class="line">	<span class="comment">//data = append(data, block.Hash...)</span></span><br><span class="line"></span><br><span class="line">	tmp := [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">		uintToByte(block.Version),</span><br><span class="line">		block.PrevBlockHash,</span><br><span class="line">		block.MerkleRoot,</span><br><span class="line">		uintToByte(block.TimeStamp),</span><br><span class="line">		uintToByte(block.Difficulity),</span><br><span class="line">		uintToByte(block.Nonce),</span><br><span class="line">		block.Data,</span><br><span class="line">	&#125;</span><br><span class="line">	data = bytes.Join(tmp, []<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	hash := sha256.Sum256(data) <span class="comment">//hash是一个32位的数组</span></span><br><span class="line">	block.Hash = hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="当前版本问题"><a href="#当前版本问题" class="headerlink" title="当前版本问题"></a>当前版本问题</h3><h4 id="1-随机数和难度值是随意填写的"><a href="#1-随机数和难度值是随意填写的" class="headerlink" title="1.随机数和难度值是随意填写的"></a>1.随机数和难度值是随意填写的</h4><h4 id="2-区块的哈希值是无规则的"><a href="#2-区块的哈希值是无规则的" class="headerlink" title="2.区块的哈希值是无规则的"></a>2.区块的哈希值是无规则的</h4><h2 id="v2版本"><a href="#v2版本" class="headerlink" title="v2版本"></a>v2版本</h2><h3 id="1-创建proofofwork-go"><a href="#1-创建proofofwork-go" class="headerlink" title="1.创建proofofwork.go"></a>1.创建proofofwork.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一. 定义一个工作量证明的结构ProofOfWork</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//1. block</span></span><br><span class="line"><span class="comment">//2. 目标值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProffOfWork <span class="keyword">struct</span> &#123;</span><br><span class="line">	block *Block</span><br><span class="line"></span><br><span class="line">	<span class="comment">//来存储哈希值，他内置了一些方法</span></span><br><span class="line">	<span class="comment">//SetBytes:把bytes转成big.Int类型</span></span><br><span class="line">	<span class="comment">//SetString:把string转成big.Int类型</span></span><br><span class="line">	<span class="comment">//Cmp:比较方法</span></span><br><span class="line">	target *big.Int <span class="comment">//系统提供的固定的难度值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-提供创建POW的函数-gt-NewProofofWork-参数"><a href="#2-提供创建POW的函数-gt-NewProofofWork-参数" class="headerlink" title="2.提供创建POW的函数-&gt;NewProofofWork(参数)"></a>2.提供创建POW的函数-&gt;NewProofofWork(参数)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供创建POW的函数-&gt;NewProofofWork(参数)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProofofWork</span><span class="params">(block *Block)</span> *<span class="title">ProffOfWork</span></span> &#123;</span><br><span class="line">	pow := ProffOfWork&#123;</span><br><span class="line">		block: block,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//写难度值，难度值应该是推导出来的，但是为了简化，先写难度值为固定的</span></span><br><span class="line">	<span class="comment">//16进制格式的字符串</span></span><br><span class="line">	targetStr := <span class="string">&quot;0000100000000000000000000000000000000000000000000000000000000000&quot;</span></span><br><span class="line">	<span class="keyword">var</span> bigIntTmp big.Int</span><br><span class="line">	bigIntTmp.SetString(targetStr, <span class="number">16</span>)</span><br><span class="line">	pow.target = &amp;bigIntTmp</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;pow</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行修改程序推导难度值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProofOfWork</span><span class="params">(block *Block)</span> *<span class="title">ProffOfWork</span></span> &#123;</span><br><span class="line">	pow := ProffOfWork&#123;</span><br><span class="line">		block: block,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//程序推导难度值</span></span><br><span class="line">	<span class="comment">//目标值</span></span><br><span class="line">	<span class="comment">//0000100000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="comment">//0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line">	<span class="comment">//向左移动256位</span></span><br><span class="line">	<span class="comment">//1 0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">	<span class="comment">//向右移动5次，一个16进制表示4个2进制，因此向右移动20位</span></span><br><span class="line">	<span class="comment">//1 0000100000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">	bigIntTmp := big.NewInt(<span class="number">1</span>)</span><br><span class="line">	bigIntTmp.Lsh(bigIntTmp, <span class="number">256</span>)  <span class="comment">//向左移256位</span></span><br><span class="line">	bigIntTmp.Rsh(bigIntTmp, Bits) <span class="comment">//向右移动20位</span></span><br><span class="line"></span><br><span class="line">	pow.target = bigIntTmp</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;pow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-提供计算不断计算hash的函数-gt-run"><a href="#3-提供计算不断计算hash的函数-gt-run" class="headerlink" title="3.提供计算不断计算hash的函数-&gt;run()"></a>3.提供计算不断计算hash的函数-&gt;run()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是pow的运算函数，为了获取挖矿的随机数，同时返回区块的哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProffOfWork)</span> <span class="title">Run</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//1. 获取block数据</span></span><br><span class="line">	<span class="comment">//2. 拼接nonce</span></span><br><span class="line">	<span class="comment">//3. sha256</span></span><br><span class="line">	<span class="comment">//4. 与难度值进行比较，哈希值大于难度值，nonce++，小于难度值则挖矿成功</span></span><br><span class="line">	<span class="keyword">var</span> nonce <span class="keyword">uint64</span></span><br><span class="line">	<span class="keyword">var</span> hash [<span class="number">32</span>]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		hash = sha256.Sum256(pow.prepareData(nonce))</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将hash(数组类型)转成big.Int，然后与pow.target比较</span></span><br><span class="line">		<span class="keyword">var</span> bigIntTmp big.Int</span><br><span class="line">		bigIntTmp.SetBytes(hash[:])</span><br><span class="line"></span><br><span class="line">		<span class="comment">//func (x *Int) Cmp(y *Int) (r int)</span></span><br><span class="line">		<span class="comment">//Cmp compares x and y and returns:</span></span><br><span class="line">		<span class="comment">//-1 if x &lt;  y</span></span><br><span class="line">		<span class="comment">// 0 if x == y</span></span><br><span class="line">		<span class="comment">//+1 if x &gt;  y</span></span><br><span class="line">		<span class="keyword">if</span> bigIntTmp.Cmp(pow.target) == <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="comment">//此时x&lt;y，挖矿成功</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;挖矿成功！nonce:%d，哈希值为:%x\n&quot;</span>, nonce, hash)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			nonce++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hash[:], nonce</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//prepareData用来计算hash值供run方法调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProffOfWork)</span> <span class="title">prepareData</span><span class="params">(nonce <span class="keyword">uint64</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	block := pow.block</span><br><span class="line"></span><br><span class="line">	tmp := [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">		uintToByte(block.Version),</span><br><span class="line">		block.PrevBlockHash,</span><br><span class="line">		block.MerkleRoot,</span><br><span class="line">		uintToByte(block.TimeStamp),</span><br><span class="line">		uintToByte(block.Difficulity),</span><br><span class="line">		uintToByte(block.Nonce),</span><br><span class="line">		block.Data,</span><br><span class="line">	&#125;</span><br><span class="line">	data := bytes.Join(tmp, []<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-删除SetHash函数，并修改NewBlock函数"><a href="#4-删除SetHash函数，并修改NewBlock函数" class="headerlink" title="4. 删除SetHash函数，并修改NewBlock函数"></a>4. 删除SetHash函数，并修改NewBlock函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建区块 对Block的每一个字段填充数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(data <span class="keyword">string</span>, prevBlockHash []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line">	block := Block&#123;</span><br><span class="line">		Version:       <span class="number">00</span>,</span><br><span class="line">		PrevBlockHash: prevBlockHash,</span><br><span class="line">		MerkleRoot:    []<span class="keyword">byte</span>&#123;&#125;, <span class="comment">//先填充为空</span></span><br><span class="line">		TimeStamp:     <span class="keyword">uint64</span>(time.Now().Unix()),</span><br><span class="line">		Difficulity:   <span class="number">10</span>,           <span class="comment">//随便写的</span></span><br><span class="line">		Nonce:         <span class="number">10</span>,           <span class="comment">//随便写的</span></span><br><span class="line">		Hash:          []<span class="keyword">byte</span>&#123;&#125;,     <span class="comment">//先填充为空</span></span><br><span class="line">		Data:          []<span class="keyword">byte</span>(data), <span class="comment">//类型转换</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//block.SetHash()</span></span><br><span class="line">	pow := NewProofOfWork(&amp;block)</span><br><span class="line">	hash, nonce := pow.Run()</span><br><span class="line">	block.Hash = hash</span><br><span class="line">	block.Nonce = nonce</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-证明校验函数IsValid-，校验挖矿是否有效"><a href="#5-证明校验函数IsValid-，校验挖矿是否有效" class="headerlink" title="5. 证明校验函数IsValid()，校验挖矿是否有效"></a>5. 证明校验函数IsValid()，校验挖矿是否有效</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工作量证明校验</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProffOfWork)</span> <span class="title">IsValid</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   <span class="comment">//在校验的时候 block里面的数据是完整的 我们需要校验Hash，block数据和Nonce是否满足难度值要求</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取block数据</span></span><br><span class="line">   <span class="comment">//拼接nonce</span></span><br><span class="line">   <span class="comment">//做sha256</span></span><br><span class="line">   <span class="comment">//比较</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//block := pow.block</span></span><br><span class="line">   data := pow.prepareData(pow.block.Nonce)</span><br><span class="line">   hash := sha256.Sum256(data)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> tmp big.Int</span><br><span class="line">   tmp.SetBytes(hash[:])</span><br><span class="line"></span><br><span class="line">   <span class="comment">//if tmp.Cmp(pow.target) == -1 &#123;</span></span><br><span class="line">   <span class="comment">// return true</span></span><br><span class="line">   <span class="comment">//&#125;else&#123;</span></span><br><span class="line">   <span class="comment">// return false</span></span><br><span class="line">   <span class="comment">//&#125;or</span></span><br><span class="line">   <span class="keyword">return</span> tmp.Cmp(pow.target) == <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="当前版本问题-1"><a href="#当前版本问题-1" class="headerlink" title="当前版本问题"></a>当前版本问题</h3><h4 id="1-区块存储在内存中，每次程序执行完就释放，无法重用"><a href="#1-区块存储在内存中，每次程序执行完就释放，无法重用" class="headerlink" title="1.区块存储在内存中，每次程序执行完就释放，无法重用"></a>1.区块存储在内存中，每次程序执行完就释放，无法重用</h4><h4 id="2-创建区块不灵活，创建区块在main函数中写死了，无法随意添加区块"><a href="#2-创建区块不灵活，创建区块在main函数中写死了，无法随意添加区块" class="headerlink" title="2.创建区块不灵活，创建区块在main函数中写死了，无法随意添加区块"></a>2.创建区块不灵活，创建区块在main函数中写死了，无法随意添加区块</h4><h2 id="V3版本"><a href="#V3版本" class="headerlink" title="V3版本"></a>V3版本</h2><h3 id="1-安装bolt，写一个demo进行测试"><a href="#1-安装bolt，写一个demo进行测试" class="headerlink" title="1. 安装bolt，写一个demo进行测试"></a>1. 安装bolt，写一个demo进行测试</h3><p>在终端执行go get github.com/boltdb/bolt/…命令</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	db, err := bolt.Open(<span class="string">&quot;test.db&quot;</span>, <span class="number">0600</span>, <span class="literal">nil</span>) <span class="comment">//&quot;test.db&quot;是数据库名称 0600是读写</span></span><br><span class="line">	<span class="comment">//向数据库中写入数据</span></span><br><span class="line">	<span class="comment">//从数据库中读取数据</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="comment">//所有的操作都在这里</span></span><br><span class="line"></span><br><span class="line">		b1 := tx.Bucket([]<span class="keyword">byte</span>(<span class="string">&quot;bucketName1&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> b1 == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">//如果b1为空，说明这个名字不存在，需要创建</span></span><br><span class="line">			b1, err = tx.CreateBucket([]<span class="keyword">byte</span>(<span class="string">&quot;bucketName1&quot;</span>))</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Panic(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//bucket创建成功，准备写入数据</span></span><br><span class="line">		<span class="comment">//写数据使用Put，读数据使用Get</span></span><br><span class="line">		err = b1.Put([]<span class="keyword">byte</span>(<span class="string">&quot;name&quot;</span>), []<span class="keyword">byte</span>(<span class="string">&quot;Anduin&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;写入数据失败name:Anduin&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = b1.Put([]<span class="keyword">byte</span>(<span class="string">&quot;age&quot;</span>), []<span class="keyword">byte</span>(strconv.Itoa(<span class="number">22</span>)))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;写入数据失败age:22&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//读取数据</span></span><br><span class="line">		name := b1.Get([]<span class="keyword">byte</span>(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">		age := b1.Get([]<span class="keyword">byte</span>(<span class="string">&quot;age&quot;</span>))</span><br><span class="line">		fmt.Printf(<span class="string">&quot;name:%s\n&quot;</span>, name)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;age:%s\n&quot;</span>, age)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-更新NewBlockChain方法"><a href="#2-更新NewBlockChain方法" class="headerlink" title="2.更新NewBlockChain方法"></a>2.更新NewBlockChain方法</h3><p>​    注意： </p>
<ol>
<li><p>key一定唯一</p>
</li>
<li><p>把所有的区块都写到一个bucket中</p>
</li>
<li><p>在bucket中存储两种数据：（1）. 使用区块的hash值作为key，block的字节流作为value</p>
<p>​                                           （2）. 最后一个区块的哈希值</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用bolt进行改写，需要两个字段</span></span><br><span class="line"><span class="comment">//1. bolt数据库的句柄</span></span><br><span class="line"><span class="comment">//2. 最后一个区块的哈希值</span></span><br><span class="line"><span class="keyword">type</span> BlockChain <span class="keyword">struct</span> &#123;</span><br><span class="line">	db *bolt.DB <span class="comment">//句柄</span></span><br><span class="line"></span><br><span class="line">	tail []<span class="keyword">byte</span> <span class="comment">//代表最后一个区块的哈希值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> blockChainName = <span class="string">&quot;blockChain.db&quot;</span></span><br><span class="line"><span class="keyword">const</span> blockBucketName = <span class="string">&quot;blockBucket&quot;</span></span><br><span class="line"><span class="keyword">const</span> lastHashKey = <span class="string">&quot;lastHashKey&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现创建区块链的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockChain</span><span class="params">()</span> *<span class="title">BlockChain</span></span> &#123;</span><br><span class="line">	<span class="comment">//功能分析：</span></span><br><span class="line">	<span class="comment">//1. 获得区块链数据库的句柄，打开数据库，读写数据</span></span><br><span class="line">	db, err := bolt.Open(blockChainName, <span class="number">0600</span>, <span class="literal">nil</span>) <span class="comment">//&quot;test.db&quot;是数据库名称 0600是读写</span></span><br><span class="line">	<span class="comment">//向数据库中写入数据</span></span><br><span class="line">	<span class="comment">//从数据库中读取数据</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tail []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">	db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		b := tx.Bucket([]<span class="keyword">byte</span>(blockBucketName))</span><br><span class="line">		<span class="comment">//判断是否有bucket，如果没有，创建bucket并写入创世块，写入lastHashKey数据</span></span><br><span class="line">		<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">//如果b1为空，说明这个名字不存在，需要创建</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;bucket不存在，需要创建&quot;</span>)</span><br><span class="line">			b, err = tx.CreateBucket([]<span class="keyword">byte</span>(blockBucketName))</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Panic(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//开始添加创世块</span></span><br><span class="line">			genesisBlock := NewBlock(genesisInfo, []<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">			b.Put(genesisBlock.Hash, genesisBlock.Serialize() <span class="comment">/*将区块序列化，转成字节流*/</span>)</span><br><span class="line">			b.Put([]<span class="keyword">byte</span>(lastHashKey), genesisBlock.Hash)</span><br><span class="line"></span><br><span class="line">			<span class="comment">//测试，读取写入的数据</span></span><br><span class="line">			<span class="comment">//blockInfo := b.Get(genesisBlock.Hash)</span></span><br><span class="line">			<span class="comment">//block := deSerialize(blockInfo)</span></span><br><span class="line">			<span class="comment">//fmt.Printf(&quot;解码后的block数据：%s\n&quot;, block)</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//更新tail位最后一个区块的哈希值</span></span><br><span class="line">			tail = genesisBlock.Hash</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 获取最后一个区块的哈希值，填充给tail</span></span><br><span class="line">			tail = b.Get([]<span class="keyword">byte</span>(lastHashKey))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">//返回实例</span></span><br><span class="line">	<span class="keyword">return</span> &amp;BlockChain&#123;</span><br><span class="line">		db:   db,</span><br><span class="line">		tail: tail,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-在block-go中编写Serialize-与deSerialize-编码解码区块"><a href="#3-在block-go中编写Serialize-与deSerialize-编码解码区块" class="headerlink" title="3.在block.go中编写Serialize( )与deSerialize( )编码解码区块"></a>3.在block.go中编写Serialize( )与deSerialize( )编码解码区块</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. gob是go语言内置的编码包</span></span><br><span class="line"><span class="comment">//2. 他可以对任意数据类型进行编码和解码</span></span><br><span class="line"><span class="comment">//3. 编码时，先要创建编码器，编码器进行编码</span></span><br><span class="line"><span class="comment">//4. 解码时，先要创建解码器，解码器进行解码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化 将区块转换成字节流</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(block *Block)</span> <span class="title">Serialize</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义编码器</span></span><br><span class="line">	encoder := gob.NewEncoder(&amp;buffer)</span><br><span class="line">	<span class="comment">//编码器对结构进行编码</span></span><br><span class="line">	err := encoder.Encode(&amp;block)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buffer.Bytes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deSerialize</span><span class="params">(data []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;需要解码的数据：%x\n&quot;</span>, data)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> block Block</span><br><span class="line">	decoder := gob.NewDecoder(bytes.NewReader(data))</span><br><span class="line">	<span class="comment">//解码器对结构进行解码</span></span><br><span class="line">	err := decoder.Decode(&amp;block)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-更新AddBlock方法"><a href="#4-更新AddBlock方法" class="headerlink" title="4. 更新AddBlock方法"></a>4. 更新AddBlock方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">AddBlock</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	bc.db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		b := tx.Bucket([]<span class="keyword">byte</span>(blockBucketName))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">//如果b1为空，说明这个名字不存在，需要检查</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;bucket不存在，请检查&quot;</span>)</span><br><span class="line">			os.Exit(<span class="number">1</span>) <span class="comment">//退出</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建一个区块</span></span><br><span class="line">		block := NewBlock(data, bc.tail)</span><br><span class="line">		b.Put(block.Hash, block.Serialize() <span class="comment">/*将区块序列化，转成字节流*/</span>)</span><br><span class="line">		b.Put([]<span class="keyword">byte</span>(lastHashKey), block.Hash)</span><br><span class="line"></span><br><span class="line">		<span class="comment">//测试，读取写入的数据</span></span><br><span class="line">		<span class="comment">//blockInfo := b.Get(block.Hash)</span></span><br><span class="line">		<span class="comment">//nowblock := deSerialize(blockInfo)</span></span><br><span class="line">		<span class="comment">//fmt.Printf(&quot;解码后的block数据：%s\n&quot;, nowblock)</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新tail位最后一个区块的哈希值</span></span><br><span class="line">		bc.tail = block.Hash</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-定义、创建迭代器"><a href="#4-定义、创建迭代器" class="headerlink" title="4.定义、创建迭代器"></a>4.定义、创建迭代器</h3><p>//迭代器作用：遍历容器，将数据逐个返回，防止一次性加载到内存，所以一点一点读取</p>
<p>//迭代器包含两个元素：1. 区块链句柄db    2. 移动的指针current，存储哈希</p>
<p>db: 为了遍历账本</p>
<p>current：为了访问每一个区块</p>
<p>调用Next( )方法，要做两件事情：1. 返回当前所指向的区块的数据block   2. 指针向前移动</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个区块链的迭代器，包含db，current</span></span><br><span class="line"><span class="keyword">type</span> BlockChainIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	db      *bolt.DB <span class="comment">//账本</span></span><br><span class="line">	current []<span class="keyword">byte</span>   <span class="comment">//当前所指向区块的哈希值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建迭代器，使用bc进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">NewIterator</span><span class="params">()</span> *<span class="title">BlockChainIterator</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;BlockChainIterator&#123;</span><br><span class="line">		db:      bc.db,</span><br><span class="line">		current: bc.tail,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Next函数实现"><a href="#5-Next函数实现" class="headerlink" title="5. Next函数实现"></a>5. Next函数实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *BlockChainIterator)</span> <span class="title">Next</span><span class="params">()</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> block Block</span><br><span class="line">	<span class="comment">//读取数据库</span></span><br><span class="line">	it.db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		b := tx.Bucket([]<span class="keyword">byte</span>(blockBucketName))</span><br><span class="line">		<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;bucket不存在,请检查&quot;</span>)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//读取数据</span></span><br><span class="line">		blockInfo <span class="comment">/*block的字节流*/</span> := b.Get(it.current)</span><br><span class="line">		block = *DeSerialize(blockInfo)</span><br><span class="line"></span><br><span class="line">		it.current = block.PrevBlockHash</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-修改main函数"><a href="#6-修改main函数" class="headerlink" title="6. 修改main函数"></a>6. 修改main函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//区块实例化</span></span><br><span class="line">	<span class="comment">//block := NewBlock(genesisInfo, []byte&#123;0x000000000000000&#125;)</span></span><br><span class="line">	bc := NewBlockChain()</span><br><span class="line">	<span class="keyword">defer</span> bc.db.Close()</span><br><span class="line">	bc.AddBlock(<span class="string">&quot;the second block&quot;</span>)</span><br><span class="line">	bc.AddBlock(<span class="string">&quot;the third block&quot;</span>)</span><br><span class="line">	bc.AddBlock(<span class="string">&quot;the forth block&quot;</span>)</span><br><span class="line">	it := bc.NewIterator()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		block := it.Next()</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">&quot;-----------------------------------------------------------------&quot;</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Version : %x\n&quot;</span>, block.Version)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;PrevBlockHash : %x\n&quot;</span>, block.PrevBlockHash)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;MerkleRoot : %x\n&quot;</span>, block.MerkleRoot)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;TimeStamp  : %x\n&quot;</span>, block.TimeStamp)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Difficulity : %d\n&quot;</span>, block.Difficulity)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Nonce : %d\n&quot;</span>, block.Nonce)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Hash : %x\n&quot;</span>, block.Hash)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Data : %s\n&quot;</span>, block.Data)</span><br><span class="line">		pow := NewProofOfWork(block)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;IsValid:%v\n&quot;</span>, pow.IsValid())</span><br><span class="line">		fmt.Println(<span class="string">&quot;-----------------------------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> bytes.Equal(block.PrevBlockHash, []<span class="keyword">byte</span>&#123;&#125;) &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;区块链遍历结束&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-CLI-Run实现，创建cli-go"><a href="#7-CLI-Run实现，创建cli-go" class="headerlink" title="7. CLI-Run实现，创建cli.go"></a>7. CLI-Run实现，创建cli.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 所有的支配动作交给命令行来做</span></span><br><span class="line"><span class="comment">//2. 主函数只需要调用命令行结构即可</span></span><br><span class="line"><span class="comment">//3. 根据输入的不同命令，命令行做相应动作</span></span><br><span class="line"><span class="comment">//	1. addBlock</span></span><br><span class="line"><span class="comment">//	2. printChain</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Usage = <span class="string">`</span></span><br><span class="line"><span class="string">	./blockchain addBlock &quot;xxxxxx&quot; 添加数据到区块链</span></span><br><span class="line"><span class="string">	./blockchain printChain 打印区块链</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//CLI: command line的缩写</span></span><br><span class="line"><span class="keyword">type</span> CLI <span class="keyword">struct</span> &#123;</span><br><span class="line">	bc *BlockChain</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给CLI提供一个方法，进行命令解析，从而执行调度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmds := os.Args</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(cmds) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		fmt.Println(Usage)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> cmds[<span class="number">1</span>] &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;addBlock&quot;</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;添加区块命令被调用，数据：%s\n&quot;</span>, cmds[<span class="number">2</span>])</span><br><span class="line">		data := cmds[<span class="number">2</span>]</span><br><span class="line">		cli.AddBlock(data)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;printChain&quot;</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;打印区块链命令被调用\n&quot;</span>)</span><br><span class="line">		cli.PrintChain()</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;无效的命令，请检查\n&quot;</span>)</span><br><span class="line">		fmt.Println(Usage)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//添加区块的时候：bc.addBlock(data) ，data通过os.Args拿回来</span></span><br><span class="line">	<span class="comment">//打印区块的时候：遍历区块链，不需要外部输入数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-创建commands-go"><a href="#8-创建commands-go" class="headerlink" title="8.创建commands.go"></a>8.创建commands.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cli.go的配套文件，实现具体的命令</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span> <span class="title">AddBlock</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	cli.bc.AddBlock(data)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;添加区块成功\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span> <span class="title">PrintChain</span><span class="params">()</span></span> &#123;</span><br><span class="line">	it := cli.bc.NewIterator()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		block := it.Next()</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">&quot;-----------------------------------------------------------------&quot;</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Version : %x\n&quot;</span>, block.Version)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;PrevBlockHash : %x\n&quot;</span>, block.PrevBlockHash)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;MerkleRoot : %x\n&quot;</span>, block.MerkleRoot)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;TimeStamp  : %x\n&quot;</span>, block.TimeStamp)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Difficulity : %d\n&quot;</span>, block.Difficulity)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Nonce : %d\n&quot;</span>, block.Nonce)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Hash : %x\n&quot;</span>, block.Hash)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Data : %s\n&quot;</span>, block.Data)</span><br><span class="line">		pow := NewProofOfWork(block)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;IsValid:%v\n&quot;</span>, pow.IsValid())</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> bytes.Equal(block.PrevBlockHash, []<span class="keyword">byte</span>&#123;&#125;) &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;区块链遍历结束&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-修改main函数"><a href="#9-修改main函数" class="headerlink" title="9.修改main函数"></a>9.修改main函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	bc := NewBlockChain()</span><br><span class="line">	<span class="keyword">defer</span> bc.db.Close()</span><br><span class="line">	cli := CLI&#123;bc&#125;</span><br><span class="line">	cli.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-命令行操作"><a href="#10-命令行操作" class="headerlink" title="10.命令行操作"></a>10.命令行操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build -o blockchain.exe ./         //build项目，起名为blockchain</span><br><span class="line">blockchain						    //运行项目</span><br><span class="line">blockchain 。。。。                    //根据提示进行操作</span><br></pre></td></tr></table></figure>

<h2 id="v4版本"><a href="#v4版本" class="headerlink" title="v4版本"></a>v4版本</h2><h4 id="交易输入（TXInput）"><a href="#交易输入（TXInput）" class="headerlink" title="交易输入（TXInput）"></a>交易输入（TXInput）</h4><p>指明交易发起人可支付资金的来源，包含：</p>
<ol>
<li>引用utxo所在交易的ID（知道在哪个房间）</li>
<li>所消费utxo在output中的索引（具体位置）</li>
<li>解锁脚本（签名，公钥）</li>
</ol>
<h4 id="交易输出（TXOutput）"><a href="#交易输出（TXOutput）" class="headerlink" title="交易输出（TXOutput）"></a>交易输出（TXOutput）</h4><p>包含资金接收方的相关信息，包含：</p>
<ol>
<li>接收金额（数字）</li>
<li>锁定脚本（对方公钥的哈希，这个哈希可以通过地址反推出来，所以转账时知道地址即可）</li>
</ol>
<h4 id="交易ID"><a href="#交易ID" class="headerlink" title="交易ID"></a>交易ID</h4><p>一般是交易结构的哈希值（参考block的哈希值）</p>
<h3 id="1-新建transaction-go文件"><a href="#1-新建transaction-go文件" class="headerlink" title="1. 新建transaction.go文件"></a>1. 新建transaction.go文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义交易的结构</span></span><br><span class="line"><span class="comment">//定义input</span></span><br><span class="line"><span class="keyword">type</span> TXInput <span class="keyword">struct</span> &#123;</span><br><span class="line">	TXID    []<span class="keyword">byte</span> <span class="comment">//交易ID</span></span><br><span class="line">	Index   <span class="keyword">int64</span>  <span class="comment">//output的索引</span></span><br><span class="line">	Address <span class="keyword">string</span> <span class="comment">//解锁脚本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义output</span></span><br><span class="line"><span class="keyword">type</span> TXOutput <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value   <span class="keyword">float64</span> <span class="comment">//转账金额</span></span><br><span class="line">	Address <span class="keyword">string</span>  <span class="comment">//锁定脚本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置交易ID</span></span><br><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">	TXid      []<span class="keyword">byte</span>     <span class="comment">//交易id</span></span><br><span class="line">	TXInputs  []TXInput  <span class="comment">//所有的input</span></span><br><span class="line">	TXOutputs []TXOutput <span class="comment">//所有的output</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产交易的哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">SetTXID</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">	encoder := gob.NewEncoder(&amp;buffer)</span><br><span class="line"></span><br><span class="line">	err := encoder.Encode(tx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	hash := sha256.Sum256(buffer.Bytes())</span><br><span class="line">	tx.TXid = hash[:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现挖矿交易，只有输出，没有有效输入，不需要引用id，索引，签名</span></span><br><span class="line"><span class="comment">//maner 为矿工</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCoinbaseTX</span><span class="params">(miner <span class="keyword">string</span>)</span> *<span class="title">Transaction</span></span> &#123;</span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">	inputs := []TXInput&#123;&#123;</span><br><span class="line">		TXID:    <span class="literal">nil</span>,</span><br><span class="line">		Index:   <span class="number">-1</span>,</span><br><span class="line">		Address: genesisInfo,</span><br><span class="line">	&#125;&#125; <span class="comment">//设置特殊的值用于判断</span></span><br><span class="line">	outputs := []TXOutput&#123;&#123;</span><br><span class="line">		Value:   <span class="number">12.5</span>,</span><br><span class="line">		Address: miner,</span><br><span class="line">	&#125;&#125;</span><br><span class="line">	tx := Transaction&#123;</span><br><span class="line">		TXid:      <span class="literal">nil</span>,</span><br><span class="line">		TXInputs:  inputs,</span><br><span class="line">		TXOutputs: outputs,</span><br><span class="line">	&#125;</span><br><span class="line">	tx.SetTXID()</span><br><span class="line">	<span class="keyword">return</span> &amp;tx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-修改文件"><a href="#2-修改文件" class="headerlink" title="2. 修改文件"></a>2. 修改文件</h3><ol>
<li>改写block结构</li>
<li>逐个文件修改</li>
</ol>
<h3 id="3-模拟梅克尔根，在NewBlock中调用"><a href="#3-模拟梅克尔根，在NewBlock中调用" class="headerlink" title="3. 模拟梅克尔根，在NewBlock中调用"></a>3. 模拟梅克尔根，在NewBlock中调用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟梅克尔根，做简单处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(block *Block)</span> <span class="title">HashTransactions</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//交易的id就是交易的哈希值，将交易id拼接起来整体做哈希运算，作为梅克尔根</span></span><br><span class="line">	<span class="keyword">var</span> hashes []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">		txid := tx.TXid <span class="comment">/*[]byte*/</span></span><br><span class="line">		hashes = <span class="built_in">append</span>(hashes, txid...)</span><br><span class="line">	&#125;</span><br><span class="line">	hash := sha256.Sum256(hashes)</span><br><span class="line">	block.MerkleRoot = hash[:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在NewBlock中调用</span></span><br><span class="line">block.HashTransactions()</span><br></pre></td></tr></table></figure>

<h3 id="4-添加GetBanlance、FindMuUtxos函数"><a href="#4-添加GetBanlance、FindMuUtxos函数" class="headerlink" title="4. 添加GetBanlance、FindMuUtxos函数"></a>4. 添加GetBanlance、FindMuUtxos函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现思路：</span></span><br><span class="line"><span class="comment">//1. 遍历账本</span></span><br><span class="line"><span class="comment">//2. 遍历交易</span></span><br><span class="line"><span class="comment">//3. 遍历output</span></span><br><span class="line"><span class="comment">//4. 找到属于我的所有output</span></span><br><span class="line"><span class="comment">//5. 遍历input，把已经消耗的output剔除</span></span><br><span class="line"><span class="comment">//遍历交易输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">FindMuUtxos</span><span class="params">(address <span class="keyword">string</span>)</span> []<span class="title">TXOutput</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;FindMuUtxos\n&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> UTXOs []TXOutput <span class="comment">//返回的结构</span></span><br><span class="line">	it := bc.NewIterator()</span><br><span class="line"></span><br><span class="line">	spentUTXOs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int64</span>) <span class="comment">//标识已经消耗过的utxo的结构 ，key是交易id，value是这个id里面的output索引的数组</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历账本</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		block := it.Next()</span><br><span class="line">		<span class="comment">//遍历交易</span></span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">			<span class="comment">//遍历input</span></span><br><span class="line">			<span class="keyword">for</span> _, input := <span class="keyword">range</span> tx.TXInputs &#123;</span><br><span class="line">				<span class="keyword">if</span> input.Address == address &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了消耗过的output , index : %d\n&quot;</span>, input.Index)</span><br><span class="line">					key := <span class="keyword">string</span>(input.TXID)</span><br><span class="line">					spentUTXOs[key] = <span class="built_in">append</span>(spentUTXOs[key], input.Index)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		OUTPUT:</span><br><span class="line">			<span class="comment">//遍历output</span></span><br><span class="line">			<span class="keyword">for</span> i, output := <span class="keyword">range</span> tx.TXOutputs &#123;</span><br><span class="line">				key := <span class="keyword">string</span>(tx.TXid)</span><br><span class="line">				indexes := spentUTXOs[key]</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(indexes) != <span class="number">0</span> &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了当前这笔交易中有被消耗过的output\n&quot;</span>)</span><br><span class="line">					<span class="keyword">for</span> _, j := <span class="keyword">range</span> indexes &#123;</span><br><span class="line">						<span class="keyword">if</span> <span class="keyword">int64</span>(i) == j &#123;</span><br><span class="line">							fmt.Printf(<span class="string">&quot;i == j , 当前的output已经被消耗了，跳过不统计\n&quot;</span>)</span><br><span class="line">							<span class="keyword">continue</span> OUTPUT</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//找到属于我的output</span></span><br><span class="line">				<span class="keyword">if</span> address == output.Address &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了属于%s的output , i : %d\n&quot;</span>, address, i)</span><br><span class="line">					UTXOs = <span class="built_in">append</span>(UTXOs, output)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(block.PrevBlockHash) == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;遍历区块链结束\n&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> UTXOs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询余额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">GetBalance</span><span class="params">(address <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	utxos := bc.FindMuUtxos(address)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> total = <span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> _, utxo := <span class="keyword">range</span> utxos &#123;</span><br><span class="line">		total += utxo.Value <span class="comment">//10,3,1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s的余额为%f&quot;</span>, address, total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-在cli-go中添加getBalance命令"><a href="#5-在cli-go中添加getBalance命令" class="headerlink" title="5.  在cli.go中添加getBalance命令"></a>5.  在cli.go中添加getBalance命令</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;getBalance&quot;</span>:</span><br><span class="line">	fmt.Printf(<span class="string">&quot;获取余额命令被调用\n&quot;</span>)</span><br><span class="line">	cli.bc.GetBalance(cmds[<span class="number">2</span>]) <span class="comment">//cmd[2]为 blockchain getBalance 地址 获取地址的余额 中的地址</span></span><br></pre></td></tr></table></figure>

<h3 id="6-创建普通交易"><a href="#6-创建普通交易" class="headerlink" title="6. 创建普通交易"></a>6. 创建普通交易</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTransaction</span><span class="params">(from, to <span class="keyword">string</span>, amount <span class="keyword">float64</span>, bc *BlockChain)</span> *<span class="title">Transaction</span></span> &#123;</span><br><span class="line">	utxos := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int64</span>) <span class="comment">//标识能用的utxo</span></span><br><span class="line">	<span class="keyword">var</span> resValue <span class="keyword">float64</span>              <span class="comment">//这些utxo存储的金额</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历账本，找到属于付款人的合适的金额，把这个output找到</span></span><br><span class="line">	utxos, resValue = bc.FindNeedUtxos(from, amount)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果找到的钱不足以转账，创建交易失败</span></span><br><span class="line">	<span class="keyword">if</span> resValue &lt; amount &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;余额不足,交易失败\n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> inputs []TXInput</span><br><span class="line">	<span class="keyword">var</span> outputs []TXOutput</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将outputs转成inputs</span></span><br><span class="line">	<span class="keyword">for</span> txid, indexes := <span class="keyword">range</span> utxos &#123;</span><br><span class="line">		<span class="keyword">for</span> _, i := <span class="keyword">range</span> indexes &#123;</span><br><span class="line">			input := TXInput&#123;</span><br><span class="line">				TXID:    []<span class="keyword">byte</span>(txid),</span><br><span class="line">				Index:   i,</span><br><span class="line">				Address: from,</span><br><span class="line">			&#125;</span><br><span class="line">			inputs = <span class="built_in">append</span>(inputs, input)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建输出，创建一个属于收款人的output</span></span><br><span class="line">	output := TXOutput&#123;</span><br><span class="line">		Value:   amount,</span><br><span class="line">		Address: to,</span><br><span class="line">	&#125;</span><br><span class="line">	outputs = <span class="built_in">append</span>(outputs, output)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果有找零，创建属于付款人的output</span></span><br><span class="line">	<span class="keyword">if</span> resValue &gt; amount &#123;</span><br><span class="line">		output1 := TXOutput&#123;</span><br><span class="line">			Value:   resValue - amount,</span><br><span class="line">			Address: from,</span><br><span class="line">		&#125;</span><br><span class="line">		outputs = <span class="built_in">append</span>(outputs, output1)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建交易</span></span><br><span class="line">	tx := Transaction&#123;</span><br><span class="line">		TXid:      <span class="literal">nil</span>,</span><br><span class="line">		TXInputs:  inputs,</span><br><span class="line">		TXOutputs: outputs,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置交易id</span></span><br><span class="line">	tx.SetTXID()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回交易结构</span></span><br><span class="line">	<span class="keyword">return</span> &amp;tx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-在blockchain-go中添加FindNeedUtxos方法"><a href="#7-在blockchain-go中添加FindNeedUtxos方法" class="headerlink" title="7.在blockchain.go中添加FindNeedUtxos方法"></a>7.在blockchain.go中添加FindNeedUtxos方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历账本，找到属于付款人的合适的金额，把这个outputs找到</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">FindNeedUtxos</span><span class="params">(from <span class="keyword">string</span>, amount <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int64</span>, <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	needUtxos := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int64</span>) <span class="comment">//标识能用的utxo</span></span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">	<span class="comment">//var UTXOs []TXOutput //返回的结构</span></span><br><span class="line">	<span class="keyword">var</span> resValue <span class="keyword">float64</span> <span class="comment">//统计的金额</span></span><br><span class="line"></span><br><span class="line">	it := bc.NewIterator()</span><br><span class="line"></span><br><span class="line">	spentUTXOs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int64</span>) <span class="comment">//标识已经消耗过的utxo的结构 ，key是交易id，value是这个id里面的output索引的数组</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历账本</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		block := it.Next()</span><br><span class="line">		<span class="comment">//遍历交易</span></span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">			<span class="comment">//遍历input</span></span><br><span class="line">			<span class="keyword">for</span> _, input := <span class="keyword">range</span> tx.TXInputs &#123;</span><br><span class="line">				<span class="keyword">if</span> input.Address == from &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了消耗过的output , index : %d\n&quot;</span>, input.Index)</span><br><span class="line">					key := <span class="keyword">string</span>(input.TXID)</span><br><span class="line">					spentUTXOs[key] = <span class="built_in">append</span>(spentUTXOs[key], input.Index)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		OUTPUT:</span><br><span class="line">			<span class="comment">//遍历output</span></span><br><span class="line">			<span class="keyword">for</span> i, output := <span class="keyword">range</span> tx.TXOutputs &#123;</span><br><span class="line">				key := <span class="keyword">string</span>(tx.TXid)</span><br><span class="line">				indexes := spentUTXOs[key]</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(indexes) != <span class="number">0</span> &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了当前这笔交易中有被消耗过的output\n&quot;</span>)</span><br><span class="line">					<span class="keyword">for</span> _, j := <span class="keyword">range</span> indexes &#123;</span><br><span class="line">						<span class="keyword">if</span> <span class="keyword">int64</span>(i) == j &#123;</span><br><span class="line">							fmt.Printf(<span class="string">&quot;i == j , 当前的output已经被消耗了，跳过不统计\n&quot;</span>)</span><br><span class="line">							<span class="keyword">continue</span> OUTPUT</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//找到属于我的output</span></span><br><span class="line">				<span class="keyword">if</span> from == output.Address &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了属于%s的output , i : %d\n&quot;</span>, from, i)</span><br><span class="line">					<span class="comment">//UTXOs = append(UTXOs, output)</span></span><br><span class="line">					<span class="comment">//在这里实现控制逻辑</span></span><br><span class="line">					<span class="comment">//找到符合条件的output</span></span><br><span class="line">					<span class="comment">//添加到返回结构中needUtxos</span></span><br><span class="line">					needUtxos[key] = <span class="built_in">append</span>(needUtxos[key], <span class="keyword">int64</span>(i))</span><br><span class="line">					resValue += output.Value</span><br><span class="line"></span><br><span class="line">					<span class="comment">//判断金额是否足够，足够则直接返回，不足则继续遍历</span></span><br><span class="line">					<span class="keyword">if</span> resValue &gt;= amount &#123;</span><br><span class="line">						<span class="keyword">return</span> needUtxos, resValue</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(block.PrevBlockHash) == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;遍历区块链结束\n&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">	<span class="comment">//return utxos, 0.0</span></span><br><span class="line">	<span class="keyword">return</span> needUtxos, resValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-在commdans-go中添加send方法"><a href="#8-在commdans-go中添加send方法" class="headerlink" title="8. 在commdans.go中添加send方法"></a>8. 在commdans.go中添加send方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span> <span class="title">Send</span><span class="params">(from, to <span class="keyword">string</span>, amount <span class="keyword">float64</span>, miner, data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建挖矿交易</span></span><br><span class="line">	coinbase := NewCoinbaseTX(miner, data)</span><br><span class="line">	txs := []*Transaction&#123;coinbase&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建普通交易</span></span><br><span class="line">	tx := NewTransaction(from, to, amount, cli.bc)</span><br><span class="line">	<span class="keyword">if</span> tx != <span class="literal">nil</span> &#123;</span><br><span class="line">		txs = <span class="built_in">append</span>(txs, tx)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;发现无效交易，过滤\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加到区块</span></span><br><span class="line">	cli.bc.AddBlock(txs)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;挖矿成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-将FindNeedUtxos和FindMuUtxos进行整合"><a href="#9-将FindNeedUtxos和FindMuUtxos进行整合" class="headerlink" title="9.  将FindNeedUtxos和FindMuUtxos进行整合"></a>9.  将FindNeedUtxos和FindMuUtxos进行整合</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. FindMyUtxos：找到所有的utxo（只要output就行了）</span></span><br><span class="line"><span class="comment">//2. FindNeedUtxos：找到需要的utxo（需要output的定位）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UTXOInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	TXID   []<span class="keyword">byte</span>   <span class="comment">//交易id</span></span><br><span class="line">	Index  <span class="keyword">int64</span>    <span class="comment">//output的索引值</span></span><br><span class="line">	Output TXOutput <span class="comment">//output本身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历交易输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">FindMyUtxos</span><span class="params">(address <span class="keyword">string</span>)</span> []<span class="title">UTXOInfo</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;FindMuUtxos\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> UTXOInfos []UTXOInfo <span class="comment">//新的返回结构</span></span><br><span class="line">	it := bc.NewIterator()</span><br><span class="line"></span><br><span class="line">	spentUTXOs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int64</span>) <span class="comment">//标识已经消耗过的utxo的结构 ，key是交易id，value是这个id里面的output索引的数组</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历账本</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		block := it.Next()</span><br><span class="line">		<span class="comment">//遍历交易</span></span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">			<span class="comment">//遍历input</span></span><br><span class="line">			<span class="keyword">for</span> _, input := <span class="keyword">range</span> tx.TXInputs &#123;</span><br><span class="line">				<span class="keyword">if</span> input.Address == address &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了消耗过的output , index : %d\n&quot;</span>, input.Index)</span><br><span class="line">					key := <span class="keyword">string</span>(input.TXID)</span><br><span class="line">					spentUTXOs[key] = <span class="built_in">append</span>(spentUTXOs[key], input.Index)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		OUTPUT:</span><br><span class="line">			<span class="comment">//遍历output</span></span><br><span class="line">			<span class="keyword">for</span> i, output := <span class="keyword">range</span> tx.TXOutputs &#123;</span><br><span class="line">				key := <span class="keyword">string</span>(tx.TXid)</span><br><span class="line">				indexes := spentUTXOs[key]</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(indexes) != <span class="number">0</span> &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了当前这笔交易中有被消耗过的output\n&quot;</span>)</span><br><span class="line">					<span class="keyword">for</span> _, j := <span class="keyword">range</span> indexes &#123;</span><br><span class="line">						<span class="keyword">if</span> <span class="keyword">int64</span>(i) == j &#123;</span><br><span class="line">							fmt.Printf(<span class="string">&quot;i == j , 当前的output已经被消耗了，跳过不统计\n&quot;</span>)</span><br><span class="line">							<span class="keyword">continue</span> OUTPUT</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//找到属于我的output</span></span><br><span class="line">				<span class="keyword">if</span> address == output.Address &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了属于%s的output , i : %d\n&quot;</span>, address, i)</span><br><span class="line"></span><br><span class="line">					utxoinfo := UTXOInfo&#123;</span><br><span class="line">						TXID:   tx.TXid,</span><br><span class="line">						Index:  <span class="keyword">int64</span>(i),</span><br><span class="line">						Output: output,</span><br><span class="line">					&#125;</span><br><span class="line">					UTXOInfos = <span class="built_in">append</span>(UTXOInfos, utxoinfo)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(block.PrevBlockHash) == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;遍历区块链结束\n&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> UTXOInfos</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询余额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">GetBalance</span><span class="params">(address <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	utxoinfos := bc.FindMyUtxos(address)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> total = <span class="number">0.0</span></span><br><span class="line">	<span class="comment">//所有的output都在utxoinfos内部</span></span><br><span class="line">	<span class="comment">//获取余额时，遍历utxoinfos获取output即可</span></span><br><span class="line">	<span class="keyword">for</span> _, utxoinfo := <span class="keyword">range</span> utxoinfos &#123;</span><br><span class="line">		total += utxoinfo.Output.Value <span class="comment">//10,3,1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s的余额为%f&quot;</span>, address, total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历账本，找到属于付款人的合适的金额，把这个outputs找到</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">FindNeedUtxos</span><span class="params">(from <span class="keyword">string</span>, amount <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int64</span>, <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	needUtxos := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int64</span>) <span class="comment">//标识能用的utxo</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> resValue <span class="keyword">float64</span> <span class="comment">//统计的金额</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//复用FindMyUtxo函数，这个函数已经包含了所有的信息</span></span><br><span class="line">	utxoinfos := bc.FindMyUtxos(from)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, utxoinfo := <span class="keyword">range</span> utxoinfos &#123;</span><br><span class="line">		key := <span class="keyword">string</span>(utxoinfo.TXID)</span><br><span class="line">		needUtxos[key] = <span class="built_in">append</span>(needUtxos[key], utxoinfo.Index)</span><br><span class="line">		resValue += utxoinfo.Output.Value</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断金额是否足够，足够则直接返回，不足则继续遍历</span></span><br><span class="line">		<span class="keyword">if</span> resValue &gt;= amount &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> needUtxos, resValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-添加isCoinbase方法，判断交易是否为挖矿交易"><a href="#10-添加isCoinbase方法，判断交易是否为挖矿交易" class="headerlink" title="10. 添加isCoinbase方法，判断交易是否为挖矿交易"></a>10. 添加isCoinbase方法，判断交易是否为挖矿交易</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">IsCoinbase</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	inputs := tx.TXInputs</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(inputs) == <span class="number">1</span> &amp;&amp; inputs[<span class="number">0</span>].TXID == <span class="literal">nil</span> &amp;&amp; inputs[<span class="number">0</span>].Index == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改FindMyUtxos函数</span></span><br><span class="line"><span class="comment">//判断是否为普通交易</span></span><br><span class="line"><span class="keyword">if</span> tx.IsCoinbase() == <span class="literal">false</span> &#123;</span><br><span class="line">	<span class="comment">//是普通交易，遍历input</span></span><br><span class="line">	<span class="keyword">for</span> _, input := <span class="keyword">range</span> tx.TXInputs &#123;</span><br><span class="line">		<span class="keyword">if</span> input.Address == address &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;找到了消耗过的output , index : %d\n&quot;</span>, input.Index)</span><br><span class="line">			key := <span class="keyword">string</span>(input.TXID)</span><br><span class="line">			pentUTXOs[key] = <span class="built_in">append</span>(spentUTXOs[key], input.Index)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-添加CreateBlockChain方法"><a href="#11-添加CreateBlockChain方法" class="headerlink" title="11. 添加CreateBlockChain方法"></a>11. 添加CreateBlockChain方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建区块链</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlockChain</span><span class="params">(miner <span class="keyword">string</span>)</span> *<span class="title">BlockChain</span></span> &#123;</span><br><span class="line">	<span class="comment">//功能分析：</span></span><br><span class="line">	<span class="comment">//1. 获得区块链数据库的句柄，打开数据库，读写数据</span></span><br><span class="line">	db, err := bolt.Open(blockChainName, <span class="number">0600</span>, <span class="literal">nil</span>) <span class="comment">//&quot;test.db&quot;是数据库名称 0600是读写</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tail []<span class="keyword">byte</span></span><br><span class="line">	<span class="comment">//向数据库中写入数据</span></span><br><span class="line">	db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		b, err := tx.CreateBucket([]<span class="keyword">byte</span>(blockBucketName))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//开始添加创世块</span></span><br><span class="line">		<span class="comment">//创世块中只有一个挖矿交易,只有coinbase</span></span><br><span class="line">		coinbase := NewCoinbaseTX(miner, genesisInfo)</span><br><span class="line">		genesisBlock := NewBlock([]*Transaction&#123;coinbase&#125;, []<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">		b.Put(genesisBlock.Hash, genesisBlock.Serialize() <span class="comment">/*将区块序列化，转成字节流*/</span>)</span><br><span class="line">		b.Put([]<span class="keyword">byte</span>(lastHashKey), genesisBlock.Hash)</span><br><span class="line"></span><br><span class="line">		<span class="comment">//测试，读取写入的数据</span></span><br><span class="line">		<span class="comment">//blockInfo := b.Get(genesisBlock.Hash)</span></span><br><span class="line">		<span class="comment">//block := DeSerialize(blockInfo)</span></span><br><span class="line">		<span class="comment">//fmt.Printf(&quot;解码后的block数据：%s\n&quot;, block)</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新tail位最后一个区块的哈希值</span></span><br><span class="line">		tail = genesisBlock.Hash</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">//返回实例</span></span><br><span class="line">	<span class="keyword">return</span> &amp;BlockChain&#123;</span><br><span class="line">		db:   db,</span><br><span class="line">		tail: tail,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-修改NewBlockChain函数"><a href="#12-修改NewBlockChain函数" class="headerlink" title="12. 修改NewBlockChain函数"></a>12. 修改NewBlockChain函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockChain</span><span class="params">()</span> *<span class="title">BlockChain</span></span> &#123;</span><br><span class="line">	<span class="comment">//功能分析：</span></span><br><span class="line">	<span class="comment">//1. 获得区块链数据库的句柄，打开数据库，读写数据</span></span><br><span class="line">	db, err := bolt.Open(blockChainName, <span class="number">0600</span>, <span class="literal">nil</span>) <span class="comment">//&quot;test.db&quot;是数据库名称 0600是读写</span></span><br><span class="line">	<span class="comment">//从数据库中读取数据</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tail []<span class="keyword">byte</span></span><br><span class="line">	<span class="comment">//在数据库中读取数据</span></span><br><span class="line">	db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		b := tx.Bucket([]<span class="keyword">byte</span>(blockBucketName))</span><br><span class="line">		<span class="comment">//判断是否有bucket，如果没有，创建bucket并写入创世块，写入lastHashKey数据</span></span><br><span class="line">		<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;区块链bucket为空，请检查&quot;</span>)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取最后一个区块的哈希值，填充给tail</span></span><br><span class="line">		tail = b.Get([]<span class="keyword">byte</span>(lastHashKey))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">//返回实例</span></span><br><span class="line">	<span class="keyword">return</span> &amp;BlockChain&#123;</span><br><span class="line">		db:   db,</span><br><span class="line">		tail: tail,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-添加命令"><a href="#14-添加命令" class="headerlink" title="14.添加命令"></a>14.添加命令</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blockchain createBlockChain <span class="string">&quot;地址&quot;</span> 创建区块链</span><br></pre></td></tr></table></figure>

<h3 id="15-修改AddBlock为CreateBlockChain函数"><a href="#15-修改AddBlock为CreateBlockChain函数" class="headerlink" title="15.修改AddBlock为CreateBlockChain函数"></a>15.修改AddBlock为CreateBlockChain函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span> <span class="title">CreateBlockChain</span><span class="params">(addr <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	bc := CreateBlockChain(addr)</span><br><span class="line">	bc.db.Close()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;创建区块链成功\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-修改main函数"><a href="#16-修改main函数" class="headerlink" title="16. 修改main函数"></a>16. 修改main函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cli := CLI&#123;&#125;</span><br><span class="line">	cli.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-使用NewBlockChain改写GetBalance"><a href="#17-使用NewBlockChain改写GetBalance" class="headerlink" title="17. 使用NewBlockChain改写GetBalance"></a>17. 使用NewBlockChain改写GetBalance</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//CLI中不需要保存区块链，所有的命令在自己调用之前，自己获取区块链实例</span><br><span class="line">//自行进行修改代码</span><br></pre></td></tr></table></figure>

<h3 id="18-添加函数，判断区块链是否存在"><a href="#18-添加函数，判断区块链是否存在" class="headerlink" title="18. 添加函数，判断区块链是否存在"></a>18. 添加函数，判断区块链是否存在</h3><p>判断blockchain.db文件是否存在</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断文件是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsFileExist</span><span class="params">(Filename <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">//使用os.Stat来判断</span></span><br><span class="line">	_, err := os.Stat(Filename)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-修改代码"><a href="#19-修改代码" class="headerlink" title="19. 修改代码"></a>19. 修改代码</h3><p>添加以下语句到commands.go的每个方法中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> bc == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">defer</span> bc.db.Close()</span><br></pre></td></tr></table></figure>

<p>添加以下语句到NewBlockChain和CreateBlockChain方法中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !IsFileExist(blockChainName) &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;区块链不存在，请创建区块链\n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="当前版本存在问题："><a href="#当前版本存在问题：" class="headerlink" title="当前版本存在问题："></a>当前版本存在问题：</h3><h4 id="1-地址是用字符串代替的"><a href="#1-地址是用字符串代替的" class="headerlink" title="1.地址是用字符串代替的"></a>1.地址是用字符串代替的</h4><h4 id="2-没有校验"><a href="#2-没有校验" class="headerlink" title="2.没有校验"></a>2.没有校验</h4><h2 id="V5版本"><a href="#V5版本" class="headerlink" title="V5版本"></a>V5版本</h2><h3 id="1-创建秘钥对-gt-公钥-gt-地址"><a href="#1-创建秘钥对-gt-公钥-gt-地址" class="headerlink" title="1.   创建秘钥对-&gt;公钥-&gt;地址"></a>1.   创建秘钥对-&gt;公钥-&gt;地址</h3><h3 id="2-由公钥生成地址"><a href="#2-由公钥生成地址" class="headerlink" title="2.   由公钥生成地址"></a>2.   由公钥生成地址</h3><ol>
<li>使用椭圆曲线算法生成私钥</li>
<li>由私钥生成公钥</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//esdsaTest.go   ecdsa签名demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/ecdsa&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/elliptic&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/big&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1. 创建私钥</span></span><br><span class="line">	<span class="comment">//2. 创建公钥</span></span><br><span class="line">	<span class="comment">//3. 私钥对数据的哈希进行签名</span></span><br><span class="line">	<span class="comment">//4. 使用数据，签名，公钥进行校验</span></span><br><span class="line"></span><br><span class="line">	curve := elliptic.P256()</span><br><span class="line">	privateKey, err := ecdsa.GenerateKey(curve, rand.Reader)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pubKey := privateKey.PublicKey</span><br><span class="line"></span><br><span class="line">	data := <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">	dataHash := sha256.Sum256([]<span class="keyword">byte</span>(data))</span><br><span class="line"></span><br><span class="line">	r, s, err := ecdsa.Sign(rand.Reader, privateKey, dataHash[:])</span><br><span class="line"></span><br><span class="line">	<span class="comment">//一般传输过程中会把r，s拼成字节流再传输</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;r: %x,len(r): %d\n&quot;</span>, r.Bytes(), <span class="built_in">len</span>(r.Bytes()))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;s: %x,len(s): %d\n&quot;</span>, s.Bytes(), <span class="built_in">len</span>(s.Bytes()))</span><br><span class="line">	signagure := <span class="built_in">append</span>(r.Bytes(), s.Bytes()...)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//传输中... : 数据，签名signagure,公钥</span></span><br><span class="line">	<span class="comment">//在接收端从中间把r，s切出来</span></span><br><span class="line">	<span class="keyword">var</span> r1, s1 big.Int</span><br><span class="line">	r1Data := signagure[<span class="number">0</span> : <span class="built_in">len</span>(signagure)/<span class="number">2</span>]</span><br><span class="line">	s1Data := signagure[<span class="built_in">len</span>(signagure)/<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">	r1.SetBytes(r1Data)</span><br><span class="line">	s1.SetBytes(s1Data)</span><br><span class="line"></span><br><span class="line">	res := ecdsa.Verify(&amp;pubKey, dataHash[:], &amp;r1, &amp;s1)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;res : %v\n&quot;</span>, res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-保存私钥公钥"><a href="#3-保存私钥公钥" class="headerlink" title="3.   保存私钥公钥"></a>3.   保存私钥公钥</h3><p>​    钱包wallet.dat保存所有的公钥，私钥，地址</p>
<h3 id="4-创建wallet-go-生成新的比特币地址"><a href="#4-创建wallet-go-生成新的比特币地址" class="headerlink" title="4.  创建wallet.go 生成新的比特币地址"></a>4.  创建wallet.go 生成新的比特币地址</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WalletKeyPair <span class="keyword">struct</span> &#123;</span><br><span class="line">	PrivateKey *ecdsa.PrivateKey</span><br><span class="line">	<span class="comment">//将公钥的X,Y进行字节流拼接后传输</span></span><br><span class="line">	PublicKey []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWalletKeyPair</span><span class="params">()</span> *<span class="title">WalletKeyPair</span></span> &#123;</span><br><span class="line">	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	publicKeyRow := privateKey.PublicKey</span><br><span class="line"></span><br><span class="line">	publicKey := <span class="built_in">append</span>(publicKeyRow.X.Bytes(), publicKeyRow.Y.Bytes()...)</span><br><span class="line">	<span class="keyword">return</span> &amp;WalletKeyPair&#123;</span><br><span class="line">		PrivateKey: privateKey,</span><br><span class="line">		PublicKey:  publicKey,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WalletKeyPair)</span> <span class="title">GetAddress</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	hash := sha256.Sum256(w.PublicKey)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个hash160对象</span></span><br><span class="line">	<span class="comment">//向hash160中写入数据</span></span><br><span class="line">	<span class="comment">//做哈希运算</span></span><br><span class="line">	rip160Haher := ripemd160.New()</span><br><span class="line">	_, err := rip160Haher.Write(hash[:])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Sum函数会把结果与Sum的参数append到一起返回，传入nil防止数据污染</span></span><br><span class="line">	publicHash := rip160Haher.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	version := <span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//21字节的数据</span></span><br><span class="line">	payload := <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(version)&#125;, publicHash...)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一次哈希</span></span><br><span class="line">	first := sha256.Sum256(payload)</span><br><span class="line">	<span class="comment">//第二次哈希</span></span><br><span class="line">	second := sha256.Sum256(first[:])</span><br><span class="line"></span><br><span class="line">	<span class="comment">//取前四个字节作为校验码</span></span><br><span class="line">	checksum := second[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">//25字节的数据</span></span><br><span class="line">	payload = <span class="built_in">append</span>(payload, checksum...)</span><br><span class="line"></span><br><span class="line">	address := base58.Encode(payload)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> address</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1. 创建一个结构WalletKeyPair秘钥对，保存公钥和私钥</span></span><br><span class="line"><span class="comment">//2. 给这个结构提供一个方法GetAddress：私钥-&gt;公钥-&gt;地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WalletKeyPair <span class="keyword">struct</span> &#123;</span><br><span class="line">	PrivateKey *ecdsa.PrivateKey</span><br><span class="line">	<span class="comment">//将公钥的X,Y进行字节流拼接后传输</span></span><br><span class="line">	PublicKey []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWalletKeyPair</span><span class="params">()</span> *<span class="title">WalletKeyPair</span></span> &#123;</span><br><span class="line">	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	publicKeyRow := privateKey.PublicKey</span><br><span class="line"></span><br><span class="line">	publicKey := <span class="built_in">append</span>(publicKeyRow.X.Bytes(), publicKeyRow.Y.Bytes()...)</span><br><span class="line">	<span class="keyword">return</span> &amp;WalletKeyPair&#123;</span><br><span class="line">		PrivateKey: privateKey,</span><br><span class="line">		PublicKey:  publicKey,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-克隆git-github-com-golang-crypto-git"><a href="#5-克隆git-github-com-golang-crypto-git" class="headerlink" title="5 .克隆git://github.com/golang/crypto.git"></a>5 .克隆git://github.com/golang/crypto.git</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git:<span class="comment">//github.com/golang/crypto.git</span></span><br></pre></td></tr></table></figure>

<h3 id="6-添加Wallets-go文件"><a href="#6-添加Wallets-go文件" class="headerlink" title="6. 添加Wallets.go文件"></a>6. 添加Wallets.go文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wallets结构</span></span><br><span class="line"><span class="comment">//把地址和秘钥对一一对应起来</span></span><br><span class="line"><span class="comment">//map[address]——&gt;walletKeyPair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wallets <span class="keyword">struct</span> &#123;</span><br><span class="line">	WalletsMap <span class="keyword">map</span>[<span class="keyword">string</span>]*WalletKeyPair</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Wallets，返回Wallets的实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWallets</span><span class="params">()</span> *<span class="title">Wallets</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ws Wallets</span><br><span class="line">	ws.WalletsMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*WalletKeyPair)</span><br><span class="line">	<span class="comment">//1. 把所有的钱包从本地加载出来</span></span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">	<span class="comment">//2. 返回实例</span></span><br><span class="line">	<span class="keyword">return</span> &amp;ws</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个Wallets是对外的，WalletKeyPair是对内的，Wallets调用WalletKeyPair</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ws *Wallets)</span> <span class="title">CreateWallet</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">//1. 调用NewWalletKeyPair</span></span><br><span class="line">	wallet := NewWalletKeyPair()</span><br><span class="line">	<span class="comment">//2. 将返回的WalletKeyPair添加到WalletMap中</span></span><br><span class="line">	address := wallet.GetAddress()</span><br><span class="line"></span><br><span class="line">	ws.WalletsMap[address] = wallet</span><br><span class="line">	<span class="comment">//3. 保存到本地文件</span></span><br><span class="line">	res := ws.SaveToFile()</span><br><span class="line">	<span class="keyword">if</span> !res &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;创建钱包失败\n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> address</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-添加创建文件方法"><a href="#7-添加创建文件方法" class="headerlink" title="7.添加创建文件方法"></a>7.添加创建文件方法</h3><ol>
<li>gob.Register：对于结构中的interface类型，需要明确类型</li>
<li>iotutil.WhiteFile：实现文件写入</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WalletName = <span class="string">&quot;wallet.dat&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//保存钱包到文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ws *Wallets)</span> <span class="title">SaveToFile</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将接口类型明确注册 否则会报错</span></span><br><span class="line">	gob.Register(elliptic.P256())</span><br><span class="line"></span><br><span class="line">	encoder := gob.NewEncoder(&amp;buffer)</span><br><span class="line"></span><br><span class="line">	err := encoder.Encode(ws)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;钱包序列化失败: %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	content := buffer.Bytes()</span><br><span class="line">	err = ioutil.WriteFile(WalletName, content, <span class="number">0600</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;钱包创建失败\n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-添加读取文件方法"><a href="#8-添加读取文件方法" class="headerlink" title="8.添加读取文件方法"></a>8.添加读取文件方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ws *Wallets)</span> <span class="title">LoadFromFile</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">//判断文件是否存在</span></span><br><span class="line">	<span class="keyword">if</span> !IsFileExist(WalletName) &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;钱包文件不存在，准备创建\n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取文件</span></span><br><span class="line">	content, err := ioutil.ReadFile(WalletName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gob.Register(elliptic.P256())</span><br><span class="line"></span><br><span class="line">	<span class="comment">//gob解码</span></span><br><span class="line">	decoder := gob.NewDecoder(bytes.NewReader(content))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wallets Wallets</span><br><span class="line"></span><br><span class="line">	err = decoder.Decode(&amp;wallets)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//赋值给ws</span></span><br><span class="line">	ws.WalletsMap = wallets.WalletsMap</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-添加打印钱包地址命令"><a href="#9-添加打印钱包地址命令" class="headerlink" title="9.添加打印钱包地址命令"></a>9.添加打印钱包地址命令</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历map打印地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ws *Wallets)</span> <span class="title">ListAddress</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> addresses []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> address, _ := <span class="keyword">range</span> ws.WalletsMap &#123;</span><br><span class="line">		addresses = <span class="built_in">append</span>(addresses, address)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> addresses</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CLI)</span> <span class="title">ListAddress</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ws := NewWallets()</span><br><span class="line">	addresses := ws.ListAddress()</span><br><span class="line">	<span class="keyword">for</span> _, address := <span class="keyword">range</span> addresses &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;address : %s\n&quot;</span>, address)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-改写TXInput和TXOutput的结构"><a href="#10-改写TXInput和TXOutput的结构" class="headerlink" title="10.改写TXInput和TXOutput的结构"></a>10.改写TXInput和TXOutput的结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义交易的结构</span></span><br><span class="line"><span class="comment">//定义input</span></span><br><span class="line"><span class="keyword">type</span> TXInput <span class="keyword">struct</span> &#123;</span><br><span class="line">	TXID  []<span class="keyword">byte</span> <span class="comment">//交易ID</span></span><br><span class="line">	Index <span class="keyword">int64</span>  <span class="comment">//output的索引</span></span><br><span class="line">	<span class="comment">//Address string //解锁脚本</span></span><br><span class="line">	Signature []<span class="keyword">byte</span> <span class="comment">//交易签名</span></span><br><span class="line"></span><br><span class="line">	pubKey []<span class="keyword">byte</span> <span class="comment">//公钥本身，不是公钥哈希</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义output</span></span><br><span class="line"><span class="keyword">type</span> TXOutput <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="keyword">float64</span> <span class="comment">//转账金额</span></span><br><span class="line">	<span class="comment">//Address string  //锁定脚本</span></span><br><span class="line"></span><br><span class="line">	PubKeyHash []<span class="keyword">byte</span> <span class="comment">//公钥哈希</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-添加Lock方法和NewTXOutput方法"><a href="#11-添加Lock方法和NewTXOutput方法" class="headerlink" title="11.添加Lock方法和NewTXOutput方法"></a>11.添加Lock方法和NewTXOutput方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定转账地址，得到该地址的公钥哈希，完成对output 的锁定</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(output *TXOutput)</span> <span class="title">Lock</span><span class="params">(address <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//address-&gt;public key hash</span></span><br><span class="line">	<span class="comment">//25字节</span></span><br><span class="line">	decodeInfo, err := base58.Decode(address)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	pubKeyHash := decodeInfo[<span class="number">1</span> : <span class="built_in">len</span>(decodeInfo)<span class="number">-4</span>]</span><br><span class="line"></span><br><span class="line">	output.PubKeyHash = pubKeyHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTXOutput</span><span class="params">(value <span class="keyword">float64</span>, address <span class="keyword">string</span>)</span> <span class="title">TXOutput</span></span> &#123;</span><br><span class="line">	output := TXOutput&#123;</span><br><span class="line">		Value: value,</span><br><span class="line">	&#125;</span><br><span class="line">	output.Lock(address)</span><br><span class="line">	<span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-改写NewCoinbaseTX函数"><a href="#12-改写NewCoinbaseTX函数" class="headerlink" title="12.改写NewCoinbaseTX函数"></a>12.改写NewCoinbaseTX函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//挖矿奖励</span></span><br><span class="line"><span class="keyword">const</span> reward = <span class="number">12.5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCoinbaseTX</span><span class="params">(miner <span class="keyword">string</span>, data <span class="keyword">string</span>)</span> *<span class="title">Transaction</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	inputs := []TXInput&#123;&#123;</span><br><span class="line">		TXID:      <span class="literal">nil</span>,</span><br><span class="line">		Index:     <span class="number">-1</span>,</span><br><span class="line">		Signature: <span class="literal">nil</span>,</span><br><span class="line">		pubKey:    []<span class="keyword">byte</span>(data),</span><br><span class="line">	&#125;&#125; <span class="comment">//设置特殊的值用于判断</span></span><br><span class="line">	output := NewTXOutput(reward, miner)</span><br><span class="line">	outputs := []TXOutput&#123;output&#125;</span><br><span class="line">	tx := Transaction&#123;</span><br><span class="line">		TXid:      <span class="literal">nil</span>,</span><br><span class="line">		TXInputs:  inputs,</span><br><span class="line">		TXOutputs: outputs,</span><br><span class="line">	&#125;</span><br><span class="line">	tx.SetTXID()</span><br><span class="line">	<span class="keyword">return</span> &amp;tx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-改写NewTransaction函数"><a href="#13-改写NewTransaction函数" class="headerlink" title="13.改写NewTransaction函数"></a>13.改写NewTransaction函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTransaction</span><span class="params">(from, to <span class="keyword">string</span>, amount <span class="keyword">float64</span>, bc *BlockChain)</span> *<span class="title">Transaction</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开钱包</span></span><br><span class="line">	ws := NewWallets()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取秘钥对</span></span><br><span class="line">	Wallet := ws.WalletsMap[from]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> Wallet == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;这个地址的私钥不存在，交易创建失败\n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取公钥，私钥</span></span><br><span class="line">	<span class="comment">//privateKey := Wallet.PrivateKey</span></span><br><span class="line">	publicKey := Wallet.PublicKey</span><br><span class="line">	pubKeyHash := hashPubKey(from)</span><br><span class="line"></span><br><span class="line">	utxos := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int64</span>) <span class="comment">//标识能用的utxo</span></span><br><span class="line">	<span class="keyword">var</span> resValue <span class="keyword">float64</span>              <span class="comment">//这些utxo存储的金额</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历账本，找到属于付款人的合适的金额，把这个outputs找到</span></span><br><span class="line">	utxos, resValue = bc.FindNeedUtxos(pubKeyHash, amount)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果找到的钱不足以转账，创建交易失败</span></span><br><span class="line">	<span class="keyword">if</span> resValue &lt; amount &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;余额不足,交易失败\n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> inputs []TXInput</span><br><span class="line">	<span class="keyword">var</span> outputs []TXOutput</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将outputs转成inputs</span></span><br><span class="line">	<span class="keyword">for</span> txid, indexes := <span class="keyword">range</span> utxos &#123;</span><br><span class="line">		<span class="keyword">for</span> _, i := <span class="keyword">range</span> indexes &#123;</span><br><span class="line">			input := TXInput&#123;</span><br><span class="line">				TXID:      []<span class="keyword">byte</span>(txid),</span><br><span class="line">				Index:     i,</span><br><span class="line">				Signature: <span class="literal">nil</span>,</span><br><span class="line">				pubKey:    publicKey,</span><br><span class="line">			&#125;</span><br><span class="line">			inputs = <span class="built_in">append</span>(inputs, input)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建输出，创建一个属于收款人的output</span></span><br><span class="line">	output := NewTXOutput(amount, to)</span><br><span class="line">	outputs = <span class="built_in">append</span>(outputs, output)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果有找零，创建属于付款人的output</span></span><br><span class="line">	<span class="keyword">if</span> resValue &gt; amount &#123;</span><br><span class="line">		output1 := NewTXOutput(resValue-amount, from)</span><br><span class="line">		outputs = <span class="built_in">append</span>(outputs, output1)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建交易</span></span><br><span class="line">	tx := Transaction&#123;</span><br><span class="line">		TXid:      <span class="literal">nil</span>,</span><br><span class="line">		TXInputs:  inputs,</span><br><span class="line">		TXOutputs: outputs,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置交易id</span></span><br><span class="line">	tx.SetTXID()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回交易结构</span></span><br><span class="line">	<span class="keyword">return</span> &amp;tx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-使用HashPubKey和CheckSum函数改写GetAddress"><a href="#14-使用HashPubKey和CheckSum函数改写GetAddress" class="headerlink" title="14.使用HashPubKey和CheckSum函数改写GetAddress"></a>14.使用HashPubKey和CheckSum函数改写GetAddress</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WalletKeyPair)</span> <span class="title">GetAddress</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	publicHash := HashPubKey(w.PublicKey)</span><br><span class="line"></span><br><span class="line">	version := <span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//21字节的数据</span></span><br><span class="line">	payload := <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(version)&#125;, publicHash...)</span><br><span class="line"></span><br><span class="line">	checksum := CheckSum(payload)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//25字节的数据</span></span><br><span class="line">	payload = <span class="built_in">append</span>(payload, checksum...)</span><br><span class="line"></span><br><span class="line">	address := base58.Encode(payload)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HashPubKey</span><span class="params">(pubKey []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	hash := sha256.Sum256(pubKey)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个hash160对象</span></span><br><span class="line">	<span class="comment">//向hash160中写入数据</span></span><br><span class="line">	<span class="comment">//做哈希运算</span></span><br><span class="line">	rip160Haher := ripemd160.New()</span><br><span class="line">	_, err := rip160Haher.Write(hash[:])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Sum函数会把结果与Sum的参数append到一起返回，传入nil防止数据污染</span></span><br><span class="line">	publicHash := rip160Haher.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> publicHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckSum</span><span class="params">(payload []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">//第一次哈希</span></span><br><span class="line">	first := sha256.Sum256(payload)</span><br><span class="line">	<span class="comment">//第二次哈希</span></span><br><span class="line">	second := sha256.Sum256(first[:])</span><br><span class="line"></span><br><span class="line">	<span class="comment">//取前四个字节作为校验码</span></span><br><span class="line">	checksum := second[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">	<span class="keyword">return</span> checksum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-改写blockchain中相关代码"><a href="#15-改写blockchain中相关代码" class="headerlink" title="15.改写blockchain中相关代码"></a>15.改写blockchain中相关代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;./base58&quot;</span></span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/boltdb/bolt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用bolt进行改写，需要两个字段</span></span><br><span class="line"><span class="comment">//1. bolt数据库的句柄</span></span><br><span class="line"><span class="comment">//2. 最后一个区块的哈希值</span></span><br><span class="line"><span class="keyword">type</span> BlockChain <span class="keyword">struct</span> &#123;</span><br><span class="line">	db *bolt.DB <span class="comment">//句柄</span></span><br><span class="line"></span><br><span class="line">	tail []<span class="keyword">byte</span> <span class="comment">//代表最后一个区块的哈希值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> blockChainName = <span class="string">&quot;blockChain.db&quot;</span></span><br><span class="line"><span class="keyword">const</span> blockBucketName = <span class="string">&quot;blockBucket&quot;</span></span><br><span class="line"><span class="keyword">const</span> lastHashKey = <span class="string">&quot;lastHashKey&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建区块链</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlockChain</span><span class="params">(miner <span class="keyword">string</span>)</span> *<span class="title">BlockChain</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> IsFileExist(blockChainName) &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;区块链已经存在，不需要重复创建\n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//功能分析：</span></span><br><span class="line">	<span class="comment">//1. 获得区块链数据库的句柄，打开数据库，读写数据</span></span><br><span class="line">	db, err := bolt.Open(blockChainName, <span class="number">0600</span>, <span class="literal">nil</span>) <span class="comment">//&quot;test.db&quot;是数据库名称 0600是读写</span></span><br><span class="line">	<span class="comment">//从数据库中读取数据</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tail []<span class="keyword">byte</span></span><br><span class="line">	<span class="comment">//向数据库中写入数据</span></span><br><span class="line">	db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		b, err := tx.CreateBucket([]<span class="keyword">byte</span>(blockBucketName))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//开始添加创世块</span></span><br><span class="line">		<span class="comment">//创世块中只有一个挖矿交易,只有coinbase</span></span><br><span class="line">		coinbase := NewCoinbaseTX(miner, genesisInfo)</span><br><span class="line">		genesisBlock := NewBlock([]*Transaction&#123;coinbase&#125;, []<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">		b.Put(genesisBlock.Hash, genesisBlock.Serialize() <span class="comment">/*将区块序列化，转成字节流*/</span>)</span><br><span class="line">		b.Put([]<span class="keyword">byte</span>(lastHashKey), genesisBlock.Hash)</span><br><span class="line"></span><br><span class="line">		<span class="comment">//测试，读取写入的数据</span></span><br><span class="line">		<span class="comment">//blockInfo := b.Get(genesisBlock.Hash)</span></span><br><span class="line">		<span class="comment">//block := DeSerialize(blockInfo)</span></span><br><span class="line">		<span class="comment">//fmt.Printf(&quot;解码后的block数据：%s\n&quot;, block)</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新tail位最后一个区块的哈希值</span></span><br><span class="line">		tail = genesisBlock.Hash</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">//返回实例</span></span><br><span class="line">	<span class="keyword">return</span> &amp;BlockChain&#123;</span><br><span class="line">		db:   db,</span><br><span class="line">		tail: tail,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取区块链，返回区块链实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockChain</span><span class="params">()</span> *<span class="title">BlockChain</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !IsFileExist(blockChainName) &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;区块链不存在，请创建区块链\n&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//功能分析：</span></span><br><span class="line">	<span class="comment">//1. 获得区块链数据库的句柄，打开数据库，读写数据</span></span><br><span class="line">	db, err := bolt.Open(blockChainName, <span class="number">0600</span>, <span class="literal">nil</span>) <span class="comment">//&quot;test.db&quot;是数据库名称 0600是读写</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tail []<span class="keyword">byte</span></span><br><span class="line">	<span class="comment">//在数据库中读取数据</span></span><br><span class="line">	db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		b := tx.Bucket([]<span class="keyword">byte</span>(blockBucketName))</span><br><span class="line">		<span class="comment">//判断是否有bucket，如果没有，创建bucket并写入创世块，写入lastHashKey数据</span></span><br><span class="line">		<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;区块链bucket为空，请检查&quot;</span>)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取最后一个区块的哈希值，填充给tail</span></span><br><span class="line">		tail = b.Get([]<span class="keyword">byte</span>(lastHashKey))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">//返回实例</span></span><br><span class="line">	<span class="keyword">return</span> &amp;BlockChain&#123;</span><br><span class="line">		db:   db,</span><br><span class="line">		tail: tail,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">AddBlock</span><span class="params">(txs []*Transaction)</span></span> &#123;</span><br><span class="line">	bc.db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		b := tx.Bucket([]<span class="keyword">byte</span>(blockBucketName))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">//如果b1为空，说明这个名字不存在，需要检查</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;bucket不存在，请检查&quot;</span>)</span><br><span class="line">			os.Exit(<span class="number">1</span>) <span class="comment">//退出</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建一个区块</span></span><br><span class="line">		block := NewBlock(txs, bc.tail)</span><br><span class="line">		b.Put(block.Hash, block.Serialize() <span class="comment">/*将区块序列化，转成字节流*/</span>)</span><br><span class="line">		b.Put([]<span class="keyword">byte</span>(lastHashKey), block.Hash)</span><br><span class="line"></span><br><span class="line">		<span class="comment">//测试，读取写入的数据</span></span><br><span class="line">		<span class="comment">//blockInfo := b.Get(block.Hash)</span></span><br><span class="line">		<span class="comment">//nowblock := DeSerialize(blockInfo)</span></span><br><span class="line">		<span class="comment">//fmt.Printf(&quot;解码后的block数据：%s\n&quot;, nowblock)</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新tail位最后一个区块的哈希值</span></span><br><span class="line">		bc.tail = block.Hash</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器作用：遍历容器，将数据逐个返回，防止一次性加载到内存，所以一点一点读取</span></span><br><span class="line"><span class="comment">//迭代器包含两个元素：1. 区块链句柄db    2. 移动的指针current，存储哈希</span></span><br><span class="line"><span class="comment">//db: 为了遍历账本</span></span><br><span class="line"><span class="comment">//current：为了访问每一个区块</span></span><br><span class="line"><span class="comment">//调用Next( )方法，要做两件事情：1. 返回当前所指向的区块的数据block   2. 指针向前移动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个区块链的迭代器，包含db，current</span></span><br><span class="line"><span class="keyword">type</span> BlockChainIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	db      *bolt.DB <span class="comment">//账本</span></span><br><span class="line">	current []<span class="keyword">byte</span>   <span class="comment">//当前所指向区块的哈希值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建迭代器，使用bc进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">NewIterator</span><span class="params">()</span> *<span class="title">BlockChainIterator</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;BlockChainIterator&#123;</span><br><span class="line">		db:      bc.db,</span><br><span class="line">		current: bc.tail,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *BlockChainIterator)</span> <span class="title">Next</span><span class="params">()</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> block Block</span><br><span class="line">	<span class="comment">//读取数据库</span></span><br><span class="line">	it.db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		b := tx.Bucket([]<span class="keyword">byte</span>(blockBucketName))</span><br><span class="line">		<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;bucket不存在,请检查&quot;</span>)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//读取数据</span></span><br><span class="line">		blockInfo <span class="comment">/*block的字节流*/</span> := b.Get(it.current)</span><br><span class="line">		block = *DeSerialize(blockInfo)</span><br><span class="line"></span><br><span class="line">		it.current = block.PrevBlockHash</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UTXOInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	TXID   []<span class="keyword">byte</span>   <span class="comment">//交易id</span></span><br><span class="line">	Index  <span class="keyword">int64</span>    <span class="comment">//output的索引值</span></span><br><span class="line">	Output TXOutput <span class="comment">//output本身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历交易输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">FindMyUtxos</span><span class="params">(pubKeyHash []<span class="keyword">byte</span>)</span> []<span class="title">UTXOInfo</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;FindMuUtxos\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> UTXOInfos []UTXOInfo <span class="comment">//新的返回结构</span></span><br><span class="line">	it := bc.NewIterator()</span><br><span class="line"></span><br><span class="line">	spentUTXOs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int64</span>) <span class="comment">//标识已经消耗过的utxo的结构 ，key是交易id，value是这个id里面的output索引的数组</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历账本</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		block := it.Next()</span><br><span class="line">		<span class="comment">//遍历交易</span></span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//判断是否为普通交易</span></span><br><span class="line">			<span class="keyword">if</span> tx.IsCoinbase() == <span class="literal">false</span> &#123;</span><br><span class="line">				<span class="comment">//是普通交易，遍历input</span></span><br><span class="line">				<span class="keyword">for</span> _, input := <span class="keyword">range</span> tx.TXInputs &#123;</span><br><span class="line">					<span class="comment">//判断当前被使用的input是否为目标地址所有</span></span><br><span class="line">					<span class="keyword">if</span> bytes.Equal(HashPubKey(input.pubKey), pubKeyHash) &#123;</span><br><span class="line">						fmt.Printf(<span class="string">&quot;找到了消耗过的output , index : %d\n&quot;</span>, input.Index)</span><br><span class="line">						key := <span class="keyword">string</span>(input.TXID)</span><br><span class="line">						spentUTXOs[key] = <span class="built_in">append</span>(spentUTXOs[key], input.Index)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		OUTPUT:</span><br><span class="line">			<span class="comment">//遍历output</span></span><br><span class="line">			<span class="keyword">for</span> i, output := <span class="keyword">range</span> tx.TXOutputs &#123;</span><br><span class="line">				key := <span class="keyword">string</span>(tx.TXid)</span><br><span class="line">				indexes := spentUTXOs[key]</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(indexes) != <span class="number">0</span> &#123;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;找到了当前这笔交易中有被消耗过的output\n&quot;</span>)</span><br><span class="line">					<span class="keyword">for</span> _, j := <span class="keyword">range</span> indexes &#123;</span><br><span class="line">						<span class="keyword">if</span> <span class="keyword">int64</span>(i) == j &#123;</span><br><span class="line">							fmt.Printf(<span class="string">&quot;i == j , 当前的output已经被消耗了，跳过不统计\n&quot;</span>)</span><br><span class="line">							<span class="keyword">continue</span> OUTPUT</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//找到属于我的output</span></span><br><span class="line">				<span class="keyword">if</span> bytes.Equal(pubKeyHash, output.PubKeyHash) &#123;</span><br><span class="line"></span><br><span class="line">					utxoinfo := UTXOInfo&#123;</span><br><span class="line">						TXID:   tx.TXid,</span><br><span class="line">						Index:  <span class="keyword">int64</span>(i),</span><br><span class="line">						Output: output,</span><br><span class="line">					&#125;</span><br><span class="line">					UTXOInfos = <span class="built_in">append</span>(UTXOInfos, utxoinfo)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(block.PrevBlockHash) == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;遍历区块链结束\n&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> UTXOInfos</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询余额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">GetBalance</span><span class="params">(address <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	decodeInfo, err := base58.Decode(address)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	pubKeyHash := decodeInfo[<span class="number">1</span> : <span class="built_in">len</span>(decodeInfo)<span class="number">-4</span>]</span><br><span class="line"></span><br><span class="line">	utxoinfos := bc.FindMyUtxos(pubKeyHash)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> total = <span class="number">0.0</span></span><br><span class="line">	<span class="comment">//所有的output都在utxoinfos内部</span></span><br><span class="line">	<span class="comment">//获取余额时，遍历utxoinfos获取output即可</span></span><br><span class="line">	<span class="keyword">for</span> _, utxoinfo := <span class="keyword">range</span> utxoinfos &#123;</span><br><span class="line">		total += utxoinfo.Output.Value</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s的余额为%f&quot;</span>, address, total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历账本，找到属于付款人的合适的金额，把这个outputs找到</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">FindNeedUtxos</span><span class="params">(pubKeyHash []<span class="keyword">byte</span>, amount <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int64</span>, <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	needUtxos := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int64</span>) <span class="comment">//标识能用的utxo</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> resValue <span class="keyword">float64</span> <span class="comment">//统计的金额</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//复用FindMyUtxo函数，这个函数已经包含了所有的信息</span></span><br><span class="line">	utxoinfos := bc.FindMyUtxos(pubKeyHash)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, utxoinfo := <span class="keyword">range</span> utxoinfos &#123;</span><br><span class="line">		key := <span class="keyword">string</span>(utxoinfo.TXID)</span><br><span class="line">		needUtxos[key] = <span class="built_in">append</span>(needUtxos[key], utxoinfo.Index)</span><br><span class="line">		resValue += utxoinfo.Output.Value</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断金额是否足够，足够则直接返回，不足则继续遍历</span></span><br><span class="line">		<span class="keyword">if</span> resValue &gt;= amount &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> needUtxos, resValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-地址有效性校验"><a href="#16-地址有效性校验" class="headerlink" title="16.地址有效性校验"></a>16.地址有效性校验</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsValidAddress</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">//1. 将输入的地址进行解码，得到25个字节</span></span><br><span class="line">	<span class="comment">//2. 取出前21个字节，运行CheckSum函数，得到checksum1,</span></span><br><span class="line">	<span class="comment">//3. 取出后4个字节，得到checksum2</span></span><br><span class="line">	<span class="comment">//4. 比较checksum1和checksum2，如果相同则地址有效，反之无效</span></span><br><span class="line">	decodeInfo,_:= base58.Decode(address)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(decodeInfo) != <span class="number">25</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	payload := decodeInfo[<span class="number">0</span>:<span class="built_in">len</span>(decodeInfo) - <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自己求出来的校验码</span></span><br><span class="line">	checksum1 := CheckSum(payload)</span><br><span class="line">	<span class="comment">//解出来的校验码</span></span><br><span class="line">	checksum2 := decodeInfo[<span class="built_in">len</span>(decodeInfo)<span class="number">-4</span> : <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bytes.Equal(checksum1,checksum2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-对交易进行签名"><a href="#17-对交易进行签名" class="headerlink" title="17.对交易进行签名"></a>17.对交易进行签名</h3><p>我们对一笔交易签名，要填充每一个所引用的Input的sig，N个input要有N个签名，签名内容包括：</p>
<ol>
<li>所引用的Output的公钥哈希</li>
<li>所新生成的Output的公钥哈希</li>
<li>所新生成的Output的Value</li>
</ol>
<p>签名时需要找到这个Input对应的Output，或者说找到这笔交易</p>
<p>在创建交易后，对交易进行一次签名</p>
<p>做签名时，会创建一个交易的副本，会对这个副本进行替换，生成的sig放到原始交易中，因此所引用的Output放到Input的pubKey不会覆盖原有Input的pubkey，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">SignTransaction</span><span class="params">(tx *Transaction , privateKey *ecdsa.PrivateKey)</span></span>  &#123;</span><br><span class="line">	<span class="comment">//遍历账本，找到所有引用的交易</span></span><br><span class="line"></span><br><span class="line">	prevTXs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Transaction)</span><br><span class="line"></span><br><span class="line">	tx.Sign(privateKey,prevTXs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数是私钥，第二个参数是这个交易的Input所引用的所有的交易</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">Sign</span><span class="params">(privKey *ecdsa.PrivateKey , prevTXs <span class="keyword">map</span>[<span class="keyword">string</span>]Transaction)</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;对交易进行签名\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在NewTransaction后调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把查找，引用，交易的环节放到blockchain中，同时在blockchain中进行调用签名</span></span><br><span class="line"><span class="comment">//付款人在创建交易时，已经得到了所有引用的output的详细信息</span></span><br><span class="line"><span class="comment">//但是我们不去引用，因为在矿工校验的时候，矿工是没有这部分信息的，矿工需要遍历账本，找到所有引用的交易</span></span><br><span class="line"><span class="comment">//为了统一操作，所以再查询一次，进行签名</span></span><br><span class="line">bc.SignTransaction(&amp;tx,privateKey)</span><br></pre></td></tr></table></figure>

<h3 id="18-实现FindTransaction函数"><a href="#18-实现FindTransaction函数" class="headerlink" title="18.实现FindTransaction函数"></a>18.实现FindTransaction函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">FindTransaction</span><span class="params">(txid []<span class="keyword">byte</span>)</span> *<span class="title">Transaction</span></span> &#123;</span><br><span class="line">	<span class="comment">//遍历区块链的交易</span></span><br><span class="line">	<span class="comment">//通过对比id来识别</span></span><br><span class="line"></span><br><span class="line">	it := bc.NewIterator()</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		block := it.Next()</span><br><span class="line">		<span class="keyword">for</span> _,tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">			<span class="comment">//如果找到相同的id交易，直接返回交易即可</span></span><br><span class="line">			<span class="keyword">if</span> bytes.Equal(tx.TXid , txid)&#123;</span><br><span class="line">				<span class="keyword">return</span> tx</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(block.PrevBlockHash) == <span class="number">0</span>&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-实现VerifyTransaction函数"><a href="#19-实现VerifyTransaction函数" class="headerlink" title="19. 实现VerifyTransaction函数"></a>19. 实现VerifyTransaction函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//矿工校验流程</span></span><br><span class="line"><span class="comment">//1. 找到交易input所引用的所有的交易prevTXs</span></span><br><span class="line"><span class="comment">//2. 对交易进行校验</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">VerifyTransaction</span><span class="params">(tx *Transaction)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">//遍历账本，找到所有引用的交易</span></span><br><span class="line"></span><br><span class="line">	prevTXs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Transaction)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历tx的inputs，通过ID取查找所引用的交易</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, input := <span class="keyword">range</span> tx.TXInputs&#123;</span><br><span class="line">		prevTX := bc.FindTransaction(input.TXID)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> prevTX == <span class="literal">nil</span>&#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;没有找到交易, %x\n&quot;</span> ,input.TXID)</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//把找到的引用交易保存起来</span></span><br><span class="line">			prevTXs[<span class="keyword">string</span>(input.TXID)] = *prevTX</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tx.Verify(prevTXs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-在AddBlock进行交易校验"><a href="#20-在AddBlock进行交易校验" class="headerlink" title="20.在AddBlock进行交易校验"></a>20.在AddBlock进行交易校验</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func (bc *BlockChain) AddBlock(txs []*Transaction) &#123;</span><br><span class="line">	//矿工得到交易时，第一时间对交易进行验证</span><br><span class="line">	//矿工如果不验证，即使挖矿成功，广播区块后，其他的验证矿工，仍然会校验每一笔交易</span><br><span class="line">	validTXs := []*Transaction&#123;&#125;</span><br><span class="line">	for _ , tx := range txs&#123;</span><br><span class="line">		if bc.VerifyTransaction(tx)&#123;</span><br><span class="line">			fmt.Printf(&quot;该交易有效 : %x\n &quot; , tx.TXid)</span><br><span class="line">			validTXs = append(validTXs , tx)</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			fmt.Printf(&quot;发现无效的交易 : %x\n&quot;,tx.TXid)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-实现TrimmedCopy函数"><a href="#21-实现TrimmedCopy函数" class="headerlink" title="21. 实现TrimmedCopy函数"></a>21. 实现TrimmedCopy函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//裁剪copy</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">TrimmedCopy</span><span class="params">()</span> <span class="title">Transaction</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> inputs []TXInput</span><br><span class="line">	<span class="keyword">var</span> outputs []TXOutput</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _ , input := <span class="keyword">range</span> tx.TXInputs&#123;</span><br><span class="line">		input1 := TXInput&#123;</span><br><span class="line">			TXID:      input.TXID,</span><br><span class="line">			Index:     input.Index,</span><br><span class="line">			Signature: <span class="literal">nil</span>,</span><br><span class="line">			PubKey:    <span class="literal">nil</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		inputs = <span class="built_in">append</span>(inputs,input1)</span><br><span class="line">	&#125;</span><br><span class="line">	outputs = tx.TXOutputs</span><br><span class="line">	tx1 := Transaction&#123;</span><br><span class="line">		TXid:      tx.TXid,</span><br><span class="line">		TXInputs:  inputs,</span><br><span class="line">		TXOutputs: outputs,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tx1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-添加Sign函数"><a href="#22-添加Sign函数" class="headerlink" title="22.添加Sign函数"></a>22.添加Sign函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数是私钥，第二个参数是这个交易的Input所引用的所有的交易</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">Sign</span><span class="params">(privKey *ecdsa.PrivateKey , prevTXs <span class="keyword">map</span>[<span class="keyword">string</span>]Transaction)</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;对交易进行签名\n&quot;</span>)</span><br><span class="line">	<span class="comment">//1. 拷贝一份交易txCopy，做相应裁剪，把每一个Input的pubKey和Sig设置为空，output不做改变</span></span><br><span class="line">	txCopy := tx.TrimmedCopy()</span><br><span class="line">	<span class="comment">//2. 遍历txCopy.inputs，把这个input所引用的output的公钥哈希拿出来，赋值给pubKey</span></span><br><span class="line">	<span class="keyword">for</span> i , input:=<span class="keyword">range</span> txCopy.TXInputs&#123;</span><br><span class="line">		<span class="comment">//找到引用交易</span></span><br><span class="line">		prevTX := prevTXs[<span class="keyword">string</span>(input.TXID)]</span><br><span class="line">		output := prevTX.TXOutputs[input.Index]</span><br><span class="line">		<span class="comment">//input.PubKey = output.PubKeyHash</span></span><br><span class="line">		<span class="comment">//for循环迭代出来的数据是一个副本，对这个副本进行修改不会影响原始数据，因此需要使用下标方式进行修改</span></span><br><span class="line">		txCopy.TXInputs[i].PubKey = output.PubKeyHash</span><br><span class="line"></span><br><span class="line">		<span class="comment">//签名要对数据的哈希值进行签名</span></span><br><span class="line">		<span class="comment">//数据都在交易中，要求交易的哈希</span></span><br><span class="line">		<span class="comment">//Transaction的SetTXID就是对交易的哈希</span></span><br><span class="line">		<span class="comment">//可以使用交易id作为签名的内容</span></span><br><span class="line">		<span class="comment">//3. 生成要签名的数据（哈希）</span></span><br><span class="line">		txCopy.SetTXID()</span><br><span class="line">		signData := txCopy.TXid</span><br><span class="line"></span><br><span class="line">		<span class="comment">//请理，以供下笔交易信息使用，理由同上</span></span><br><span class="line">		txCopy.TXInputs[i].PubKey = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;要签名的数据, signData : %x\n&quot;</span>,signData)</span><br><span class="line"></span><br><span class="line">		<span class="comment">//4. 对数据进行签名r,s</span></span><br><span class="line">		r,s,err := ecdsa.Sign(rand.Reader,privKey,signData)</span><br><span class="line">		<span class="keyword">if</span> err !=<span class="literal">nil</span>&#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;交易签名失败 , err : %v\n&quot;</span> , err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//5. 拼接r,s为字节流，赋值给原始的交易的Sig字段</span></span><br><span class="line">		signature := <span class="built_in">append</span>(r.Bytes() , s.Bytes()...)</span><br><span class="line">		tx.TXInputs[i].Signature = signature</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-添加Verify函数"><a href="#23-添加Verify函数" class="headerlink" title="23.添加Verify函数"></a>23.添加Verify函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">Verify</span><span class="params">(prevTXs <span class="keyword">map</span>[<span class="keyword">string</span>]Transaction)</span>  <span class="title">bool</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;对交易进行校验\n&quot;</span>)</span><br><span class="line">	<span class="comment">//1. 拷贝修剪的副本</span></span><br><span class="line">	txCopy := tx.TrimmedCopy()</span><br><span class="line">	<span class="comment">//2. 遍历原始交易</span></span><br><span class="line">	<span class="keyword">for</span> i , input := <span class="keyword">range</span> tx.TXInputs&#123;</span><br><span class="line">		<span class="comment">//3. 遍历原始交易的inputs所引用的前交易prevTX</span></span><br><span class="line">		prevTX := prevTXs[<span class="keyword">string</span>(input.TXID)]</span><br><span class="line">		output := prevTX.TXOutputs[input.Index]</span><br><span class="line">		<span class="comment">//4. 找到output的公钥哈希，赋值给txCopy对应的input</span></span><br><span class="line">		txCopy.TXInputs[i].PubKey = output.PubKeyHash</span><br><span class="line">		<span class="comment">//5. 还原签名数据</span></span><br><span class="line">		txCopy.SetTXID()</span><br><span class="line">		verifyData := txCopy.TXid</span><br><span class="line">		fmt.Printf(<span class="string">&quot;verifyData : %x\n&quot;</span>,verifyData)</span><br><span class="line">		<span class="comment">//6. 校验</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//公钥字节流</span></span><br><span class="line">		pubKeyBytes := input.PubKey</span><br><span class="line">		<span class="comment">//还原签名为r,s</span></span><br><span class="line">		signature := input.Signature</span><br><span class="line">		r := big.Int&#123;&#125;</span><br><span class="line">		s := big.Int&#123;&#125;</span><br><span class="line">		rData := signature[<span class="number">0</span>:<span class="built_in">len</span>(signature)/<span class="number">2</span>]</span><br><span class="line">		sData := signature[<span class="built_in">len</span>(signature)/<span class="number">2</span>:]</span><br><span class="line">		r.SetBytes(rData)</span><br><span class="line">		s.SetBytes(sData)</span><br><span class="line">		<span class="comment">//还原公钥为Cruve,X,Y</span></span><br><span class="line">		x := big.Int&#123;&#125;</span><br><span class="line">		y := big.Int&#123;&#125;</span><br><span class="line">		xData := pubKeyBytes[<span class="number">0</span>:<span class="built_in">len</span>(pubKeyBytes)/<span class="number">2</span>]</span><br><span class="line">		yData := signature[<span class="built_in">len</span>(pubKeyBytes)/<span class="number">2</span>:]</span><br><span class="line">		x.SetBytes(xData)</span><br><span class="line">		y.SetBytes(yData)</span><br><span class="line"></span><br><span class="line">		cruve := elliptic.P256()</span><br><span class="line"></span><br><span class="line">		publicKey := ecdsa.PublicKey&#123;</span><br><span class="line">			Curve: cruve,</span><br><span class="line">			X:     &amp;x,</span><br><span class="line">			Y:     &amp;y,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//数据、签名、公钥准备完毕，开始校验</span></span><br><span class="line">		<span class="keyword">if</span> !ecdsa.Verify(&amp;publicKey,verifyData,&amp;r,&amp;s)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


                            </div>

                            
                                <section class="post-copyright">
                                    
                                            
                                                    
                                                            

                                </section>
                                
                                    <section class="post-tags">
                                        <div>
                                            <span>标签:</span>
                                            <span class="tag">
                    
                    
                        <a href="/tags/Go%E8%AF%AD%E8%A8%80/"># Go语言</a>
                    
                        
                </span>
                                        </div>
                                        <div>
                                            <a href="javascript:window.history.back();">back</a>
                                            <span>· </span>
                                            <a href="/">home</a>
                                        </div>
                                    </section>
                                    <section class="post-nav">
                                        
                                            <a class="prev" rel="prev" href="/2020/11/20/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%AD%A6%E4%B9%A0/">
                                                智能合约Solidity学习
                                            </a>
                                            
                                                
                                                    <a class="next" rel="next" href="/2020/09/09/GO%E8%AF%AD%E8%A8%80%E5%AF%86%E7%A0%81%E5%AD%A6/">
                                                        Go语言密码学
                                                    </a>
                                                    
                                    </section>


                        </article>
</div>
        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Night Scholar | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
